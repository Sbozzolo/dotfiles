#+TITLE: Emacs configuration
#+AUTHOR: Gabriele Bozzola (sbozzolo)
#+PROPERTY: header-args :tangle settings.el

* Preamble
  I don't want the setting.el to be manually modified (hence read-only-mode). In
  addition, as all the emacs packages, I add a commentary section.
  #+BEGIN_SRC emacs-lisp
    ;;; settings.el --- personal emacs config file  -*- lexical-binding: :configt ; eval: (read-only-mode 1)-*-
    ;;; Commentary:

    ;; THIS FILE HAS BEEN GENERATED.

    ;;; Code:
    ;; Use a hook so the message doesn't get clobbered by other messages.
    (add-hook 'emacs-startup-hook
              (lambda ()
                (message "Emacs ready in %s with %d garbage collections."
                         (format "%.2f seconds"
                                 (float-time
                                  (time-subtract after-init-time before-init-time)))
                         gcs-done)))
  #+END_SRC
* Personal info
  I set this information for some packages (mu4e for example).
  #+BEGIN_SRC emacs-lisp
    ;; (setq user-full-name "Gabriele Bozzola"
    ;;       user-mail-address "sbozzolator@gmail.com"
    ;;       calendar-latitude 45.46
    ;;       calendar-longitude 9.19
    ;;       calendar-location-name "Milan, Italy")

    (setq user-full-name "Gabriele Bozzola"
          user-mail-address "sbozzolator@gmail.com"
          calendar-latitude 32.22
          calendar-longitude -110.93
          calendar-location-name "Tucson, Arizona")

    ;;start calendar on Monday, set in in English
    (setq calendar-week-start-day 1)
    (setq system-time-locale:config "C")
  #+END_SRC
* Secret
  #+BEGIN_SRC emacs-lisp
    (setq secret-file "~/dotfiles/emacs/.emacs.d/secret.el")
    (when (file-exists-p secret-file) (load-file secret-file))
  #+END_SRC
* Garbage collector
  Run the garbage collector every 50 MB, this is to decrease
  the number of GC calls during the startup
  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold 50000000)
  #+END_SRC
* Setup package manager
  Minimal setting for the package manager
  #+BEGIN_SRC emacs-lisp
    (require 'package)
    ;; When package-enable-at-startup is non-nil packages are activated
    ;; after reading init file, but I want to activate it as soon as possible
    ;; with package-initialize
    (setq package-enable-at-startup nil)

    ;; Prefer MELPA over MELPA
    ;; Remember trailing "/" in the urls
    (setq package-archives
        '(("org"          . "https://orgmode.org/elpa/"         )
          ("GNU ELPA"     . "https://elpa.gnu.org/packages/"    )
          ("MELPA"        . "https://melpa.org/packages/"       ))
        package-archive-priorities
        '(("MELPA"        . 15)
          ("org"          . 10)
          ("GNU ELPA"     . 5))
    )
    ;; Activate package-system
    (package-initialize)
  #+END_SRC
* Setup use-package
  I config everything with use-package, hence if it is not installed, I want
  Emacs to install it
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (use-package use-package
                                            ;:pin melpa
      :config
      (setq use-package-always-ensure t)
      )

      (use-package benchmark-init
  :ensure t
  :config
  ;; To disable collection of benchmark data after init is done.
  (add-hook 'after-init-hook 'benchmark-init/deactivate))
    ;; Paradox is a nicer interface for package managment
    ;; Most importantly, it offers a function to update all the packages
    (use-package paradox
      :defer t
      :config
      (setq paradox-github-token sbozzolo-paradox-github-token)
      )
  #+END_SRC
* Force UTF8
  Force UTF8 everywhere, I've taken this snippet from somewhere, but
  I don't know where.
  #+BEGIN_SRC emacs-lisp
    (prefer-coding-system 'utf-8)
    (setq locale-coding-system 'utf-8)
    (set-default-coding-systems 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    ;; backwards compatibility as default-buffer-file-coding-system
    ;; is deprecated in 23.2.
    (if (boundp 'buffer-file-coding-system)
        (setq-default buffer-file-coding-system 'utf-8)
      (setq default-buffer-file-coding-system 'utf-8))

    ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
  #+END_SRC
* Buffer and file functions
  #+BEGIN_SRC emacs-lisp
    ;; Delete the current file
    (defun delete-this-file ()
      "Delete the current file, and kill the buffer."
      (interactive)
      (or (buffer-file-name) (error "No file is currently being edited"))
      (when (yes-or-no-p (format "Really delete '%s'?"
                                 (file-name-nondirectory buffer-file-name)))
        (delete-file (buffer-file-name))
        (kill-this-buffer)))

    ;; Hack for improving viewing of large files
    (defun my-find-file-check-make-large-file-read-only-hook ()
      "If a file is over a given size, make the buffer read only.
       This doesn't appy to PDFs."
      (when (and (> (buffer-size) (* 1024 1024)) (not (eq major-mode 'pdf-view-mode)))
        (setq buffer-read-only t)
        (buffer-disable-undo)
        (fundamental-mode)))

    (add-hook 'find-file-hook 'my-find-file-check-make-large-file-read-only-hook)

    ;; Rename the current file
    (defun rename-this-file-and-buffer ()
      "Renames both current buffer and file it's visiting to NEW-NAME."
      (interactive)
      (let* ((curr (buffer-file-name))
             (filename (buffer-file-name))
             (new (file-name-nondirectory (read-file-name
                   "New name: " nil nil nil
                   (and curr (file-name-nondirectory curr)))))
             (mustbenew (if (and curr (file-equal-p new curr)) 'excl t)))
        (unless filename
          (error "Buffer '%s' is not visiting a file!" curr))
        (progn
          (when (file-exists-p filename)
            (rename-file filename new 1))
          (set-visited-file-name new)
          (rename-buffer new))
        (message (concat "Now editing " new))
        (find-file new)
        )
      )

    ;;Save-as function (Taken form [[https://stackoverflow.com/questions/18770669/how-can-i-save-as-in-emacs-without-visiting-the-new-file][StackExchange]] and extended)
    (defun save-buffer-as ()
      "Write a copy of the current buffer or region to a file."
      (interactive)
      (let* ((curr (buffer-file-name))
             (new (read-file-name
                   "Copy to file: " nil nil nil
                   (and curr (file-name-nondirectory curr))))
             (mustbenew (if (and curr (file-equal-p new curr)) 'excl t)))
        (if (use-region-p)
            (write-region (region-beginning) (region-end) new nil nil nil mustbenew)
          (save-restriction
            (widen)
            (write-region (point-min) (point-max) new nil nil nil mustbenew)
            ))
        (message (concat "Now editing " new))
        (find-file new)
        )
      )
  #+END_SRC
* Backups
  Let Emacs backup files, which is life-saver in many cases!
  #+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist    '(("." . "~/.emacs.d/backup"))
          tramp-backup-directory-alist   backup-directory-alist
          temporary-directory    '(("." . "~/.emacs.d/tmp"))
          undo-tree-directory    "~/.emacs.d/undo"
          vc-make-backup-files t ;; Use version control for backups
          version-control t     ;; Use version numbers for backups.
          kept-new-versions 10 ;; Number of newest versions to keep.
          kept-old-versions 5 ;; Number of oldest versions to keep.
          delete-old-versions t ;; Don't ask to delete excess backup versions.
          backup-by-copying t) ;; Copy all files, don't rename them.
  #+END_SRC
* Customize
  #+BEGIN_SRC emacs-lisp
    ;; Move customization outside init
    (setq custom-file "~/.emacs.d/custom.el")
    (when (file-exists-p custom-file) (load custom-file 'noerror))
  #+END_SRC
* Look and feel
  #+BEGIN_SRC emacs-lisp
    ;; Disable dialog boxes
    (setq use-file-dialog nil)
    (setq use-dialog-box nil)
    ;; Disable useless startup screens
    (setq inhibit-startup-screen t)
    (setq inhibit-startup-echo-area-message "sbozzolo")
    ;; NO toolbar
    (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

    ;; Clear the scratch buffer
    (setq initial-scratch-message nil)

    ;; Shrink fringes to 1 pixel
    (fringe-mode 1)

    ;; Replace fundamental mode with text-mode as default one
    (setq-default major-mode 'text-mode)

    ;; Enable column number
    ;; (setq column-number-mode t)

    ;; When problematic operations are performed, flash the screen
    ;; instead of ringing the terminal bell.
    (setq visible-bell nil)

    ;; Show a marker in the left fringe for lines not in the buffer
    (setq indicate-empty-lines t)

    ;; Scrolling-options
    (setq scroll-step 1
          ;; scroll-margin 5
          scroll-conservatively 10000
          scroll-preserve-screen-position 1)
    ;;(setq scroll-margin 7)
    ;;(setq scroll-conservatively 5)

    ;; Visually indicate matching pairs of parentheses
    (use-package paren
      :config
      (show-paren-mode t)
      (setq show-paren-delay 0.0)
      )

    ;; Insert () [] {}
    (use-package elec-pair
      :config
      (electric-pair-mode 1)
      )

    ;; Set limit 80 columns
    (setq-default fill-column 80)

    ;; Enable all disabled commands
    (setq disabled-command-function nil)

    ;;  Use pinentry-emacs
    (use-package pinentry
      :config
      (setq epa-pinentry-mode 'loopback)
      ;; Disable external pin managers
      ;; [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Taken from here]]
      (setenv "GPG_AGENT_INFO" nil)
      (pinentry-start)
      )

    ;;  Warning when opening files bigger than 50MB
    (setq large-file-warning-threshold 50000000)

    ;; Theme
    (use-package color-theme-sanityinc-solarized
      :config
      (load-theme 'sanityinc-solarized-dark t)
      ;(load-theme 'sanityinc-solarized-light t)
      ;; Flat modeline
      (set-face-attribute 'mode-line nil :box nil)
      (set-face-attribute 'mode-line-inactive nil :box nil)
      ;;(load-theme 'sanityinc-solarized-light t)
      )

    ;; Enable prettification everywhere
    (when window-system (global-prettify-symbols-mode t))

    ;; Start find file from ~
    (setq default-directory "~/")

    ;; Yank at point not where cursor is
    (when window-system (setq mouse-yank-at-point t))

    ;; Overwrite highlithed text
    (delete-selection-mode t)

    ;; Force vertical split
    (setq split-height-threshold nil)
    (setq split-width-threshold 0)

    ;; Increase and decrease font with C-c C-+ and C-c C--
    (define-key global-map (kbd "C-c C-=") 'text-scale-increase)
    (define-key global-map (kbd "C-c C--") 'text-scale-decrease)

    (define-key global-map (kbd "C-x (") 'kmacro-start-macro-or-insert-counter)

    ;; Tab align every 4 chars
    (setq-default tab-stop-list (number-sequence 4 200 4))

    ;; Join line
    (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))

    ;; Load .el if newer than corresponding .elc
    (setq load-prefer-newer t)

    ;; When opening a file, always follow symlinks.
    (setq vc-follow-symlinks t)

    ;; When saving a file that starts with `#!', make it executable.
    (add-hook 'after-save-hook
              'executable-make-buffer-file-executable-if-script-p)

    ;; Don't assume that sentences should have two spaces after
    ;; periods.
    (setq sentence-end-double-space nil)

    ;; When you double-click on a file in the Files open it as a
    ;; buffer in the existing Emacs frame, rather than creating a new
    ;; frame just for that file.
    (setq pop-up-frames nil)

    ;; Do not print redefinitions warnings
    (setq ad-redefinition-action 'accept)

    ;; Don't ask `yes/no?', ask `y/n?'.
    (fset 'yes-or-no-p 'y-or-n-p)

    ;; Turn on syntax highlighting whenever possible.
    (global-font-lock-mode t)

    ;; Ask if you're sure that you want to close Emacs
    (setq confirm-kill-emacs 'y-or-n-p)

    ;; Indent with spaces not tabs
    (setq-default indent-tabs-mode nil)

    ;; When something changes a file, automatically refresh the
    ;; buffer containing that file so they can't get out of sync.
    (use-package autorevert
      :config
      (global-auto-revert-mode t)
      (setq global-auto-revert-non-file-buffers t
            auto-revert-verbose nil)
      (setq revert-without-query '("\\.pdf"))
      )

    (use-package alert
      :defer t
      :config
      (setq alert-default-style 'libnotify)
      )

    ;; When saving a file in a directory that doesn't exist, offer
    ;; to (recursively) create the file's parent directories.
    (add-hook 'before-save-hook
              (lambda ()
                (when buffer-file-name
                  (let ((dir (file-name-directory buffer-file-name)))
                    (when (and (not (file-exists-p dir))
                               (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                      (make-directory dir t))))))

    ;; Kill the buffer withouth asking
    (defun kill-this-buffer ()  ; for the menu bar
      "Kill the current buffer overrided to work always."
      (interactive)
      (kill-buffer (current-buffer))
      )

    (global-set-key (kbd "C-x k") 'kill-this-buffer)

    ;; Better C-a
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

                          Move point to the first non-whitespace character on this line.
                          If point is already there, move to the beginning of the line.
                          Effectively toggle between the first non-whitespace character and
                          the beginning of the line.

                          If ARG is not nil or 1, move forward ARG - 1 lines first.  If
                          point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
        (let ((line-move-visual nil))
          (forward-line (1- arg))))

      (let ((orig-point (point)))
        (back-to-indentation)
        (when (= orig-point (point))
          (move-beginning-of-line 1))))

    ;; remap C-a to `smarter-move-beginning-of-line'
    (global-set-key [remap move-beginning-of-line]
                    'smarter-move-beginning-of-line)

    ;; Kill the line backward
    (global-set-key (kbd "C-c k")  '(lambda (arg) (interactive "p") (kill-line (- 1 arg))))

    ;; When opening a new buffer change to focus to it
    ;; (Taken from [[http://stackoverflow.com/questions/6464738/how-can-i-switch-focus-after-buffer-split-in-emacs][StackExchange]])
    (defun sbozzolo/split-window-func (&optional window)
      (let ((new-window (split-window-sensibly window)))
        (if (not (active-minibuffer-window))
            (select-window new-window))))
    (setq split-window-preferred-function 'sbozzolo/split-window-func)

    ;; Fix for man-mode
    (defadvice man
        (before man activate)
      (setq split-window-preferred-function 'split-window-sensibly))
    (defadvice man
        (after man activate)
      (setq split-window-preferred-function 'sbozzolo/split-window-func)
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (when (eq major-mode 'Man-mode)
            (select-window (get-buffer-window buf 'visible))
            )
          )
        )
      )

    ;;Add in the minibuffer history only new entries
    (setq history-delete-duplicates t)

    ;; Purcell's function for changing mode for scripts
    (defun sanityinc/set-mode-for-new-scripts ()
      "Invoke `normal-mode' if this file is a script and in `fundamental-mode'."
      (and
       (eq major-mode 'fundamental-mode)
       (>= (buffer-size) 2)
       (save-restriction
         (widen)
         (string= "#!" (buffer-substring (point-min) (+ 2 (point-min)))))
       (normal-mode)))
    (add-hook 'after-save-hook 'sanityinc/set-mode-for-new-scripts)

    ;;Copy whole line
    (defun copy-line (arg)
      "Copy lines (as many as prefix argument) in the kill ring.
                          Ease of use features:
                          - Move to start of next line.
                          - Appends the copy on sequential calls.
                          - Use newline as last char even on the last line of the buffer.
                          - If region is active, copy its lines."
      (interactive "p")
      (let ((beg (line-beginning-position))
            (end (line-end-position arg)))
        (when mark-active
          (if (> (point) (mark))
              (setq beg (save-excursion (goto-char (mark)) (line-beginning-position)))
            (setq end (save-excursion (goto-char (mark)) (line-end-position)))))
        (if (eq last-command 'copy-line)
            (kill-append (buffer-substring beg end) (< end beg))
          (kill-ring-save beg end)))
      (kill-append "\n" nil)
      (beginning-of-line (or (and arg (1+ arg)) 2))
      (if (and arg (not (= 1 arg))) (message "%d lines copied" arg)))

    (global-set-key (kbd "C-c c")  'copy-line)

    (use-package unfill
      :bind (([remap fill-paragraph] . unfill-toggle)
             ("C-c q" . fill-sentences-in-paragraph))
      :commands (fill-sntences-in-paragraph)
      :config
      ;; From http://mbork.pl/2019-01-20_Filling_and_version_control
      (defun fill-sentences-in-paragraph ()
        "Fill the current paragraph with a newline after each sentence."
        (interactive)
        (save-excursion
          (save-restriction
            (mark-paragraph)
            (narrow-to-region (point) (mark))
            (while (not (eobp))
              (fill-region-as-paragraph
               (point)
               (progn (forward-sentence) (point)))
              (delete-horizontal-space)
              (newline)))))
      )


    ;; Open file as root if necessary
    ;; THIS DOESN'T WORK OVER TRAMP!
    (defadvice find-file (after find-file-sudo activate)
      "Find file as root if necessary."
      (unless (and buffer-file-name
                   (file-writable-p buffer-file-name))
        (find-alternate-file (concat "/sudo:root@" (system-name) ":" buffer-file-name))))

    ;; ;This automatically applies ansi-color interpretation of terminal escape sequences to compilation buffers. ;
    ;; ; https://ivanmalison.github.io/dotfiles/ ;
    ;; (defun imalison:colorize-compilation-buffer ()
    ;;   (let ((was-read-only buffer-read-only))
    ;;     (unwind-protect
    ;;         (progn
    ;;           (when was-read-only
    ;;             (read-only-mode -1))
    ;;           (ansi-color-apply-on-region (point-min) (point-max)))
    ;;       (when was-read-only
    ;;         (read-only-mode +1)))))

    ;; (add-hook 'compilation-filter-hook 'imalison:colorize-compilation-buffer)

    ;; (setq
    ;;  display-buffer-alist
    ;;  `(
    ;;    ;; Messages, errors, Calendar and REPLs in the bottom side window
    ;;    (,(rx bos (or "*Apropos"             ; Apropos buffers
    ;;                  "*Man"                 ; Man buffers
    ;;                  "*Help"                ; Help buffers
    ;;                  "*Warnings*"           ; Emacs warnings
    ;;                  "*Compile-Log*"        ; Emacs byte compiler log
    ;;                  "*compilation"         ; Compilation buffers
    ;;                  "*Flycheck errors*"    ; Flycheck error list
    ;;                  "*Calendar"            ; Calendar window
    ;;                  "*intero"              ; Intero REPL
    ;;                  "*ielm"                ; IELM REPL
    ;;                  ;; AUCTeX command output
    ;;                  (and (1+ nonl) " output*")))
    ;;     (display-buffer-reuse-window display-buffer-in-side-window)
    ;;     (side . bottom)
    ;;     (reusable-frames . visible)
    ;;     (window-height . 0.45))
    ;;    (,(rx bos "*shell")
    ;;     (display-buffer-same-window)
    ;;     (reusable-frames . nil))
    ;;    (,(rx bos "*pdf")
    ;;     (display-buffer-reuse-window display-buffer-in-side-window)
    ;;     (side . right)
    ;;     (reusable-frames . visible)
    ;;     (window-width . 0.5))
    ;;    ;; Let `display-buffer' reuse visible frames for all buffers.  This must
    ;;    ;; be the last entry in `display-buffer-alist', because it overrides any
    ;;    ;; later entry with more specific actions.
    ;;    ("." nil (reusable-frames . visible))))

  #+END_SRC
** Modeline customization
   #+BEGIN_SRC emacs-lisp
    (defun internet-up-p (&optional host)
      (interactive)
      (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1"
                         (if host host "www.google.com"))))

    (use-package spaceline
      :config
      (require 'spaceline-config)
      (spaceline-spacemacs-theme)
      (setq spaceline-buffer-encoding-abbrev-p nil)
                                            ;(setq spaceline-line-column-p nil)
      (setq spaceline-line-p nil)
      (setq powerline-default-separator (quote arrow))
      (line-number-mode 1)
      (column-number-mode 1)
      (display-time-mode 1)
      (setq display-time-24hr-format t)
      ;; (setq display-time-format "%H:%M - %d %B %Y")
      (setq display-time-default-load-average nil)
      (use-package fancy-battery
        :config
        (setq fancy-battery-show-percentage t)
        (setq battery-update-interval 15)
        (if window-system
            (fancy-battery-mode)
          (display-battery-mode)))
      (spaceline-spacemacs-theme)
      )
   #+END_SRC
* Minor-modes
  To not have the modeline full of minor modes I use globally diminish.
  #+BEGIN_SRC emacs-lisp
    (use-package diminish)
  #+END_SRC

  To handle abbreviations (buit-in, and I don't know how to use it)
  #+BEGIN_SRC emacs-lisp
    ;; (use-package abbrev
    ;;   :diminish t
    ;;   )
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package comment-dwim-2
      :hook
      (paredit-mode . (lambda () (interactive)
                        (define-key paredit-mode-map (kbd "M-;") nil) ))
      :bind ("M-;" . comment-dwim-2)
      )
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    ;; C-w kill line if no region is active
    (use-package whole-line-or-region
      :diminish whole-line-or-region-local-mode
      :hook
      ((prog-mode . whole-line-or-region-local-mode)
      (bibtex-mode . whole-line-or-region-local-mode)
      (text-mode . whole-line-or-region-local-mode))
     )
  #+END_SRC
(kill-emacs)
  Move lines with M-<up> and M-<down>
  #+BEGIN_SRC emacs-lisp
    (use-package move-text
      :config
      (move-text-default-bindings)
      )
  #+END_SRC

  Highlight line where the point is
  #+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :if (window-system)
        :config
        (global-hl-line-mode t)
        :hook
        ((term-mode . (lambda () (setq-local global-hl-line-mode nil)))
         (vterm-mode . (lambda () (setq-local global-hl-line-mode nil)))
         (eww-mode . (lambda () (setq-local global-hl-line-mode nil))))
      )

      (use-package beacon
        :config
        (beacon-mode t)
        :hook
        ((term-mode . (lambda () (setq-local beacon-mode nil)))
         (vterm-mode . (lambda () (setq-local beacon-mode nil)))
         (eww-mode . (lambda () (setq-local beacon-mode nil))))
      )
  #+END_SRC

  Winner mode for preserving my windows structure
  #+BEGIN_SRC emacs-lisp
     (use-package winner
       :config
       (winner-mode t)
       :bind
       ;; (global-set-key (kbd "C-<left>") 'winner-undo)
       ;; (global-set-key (kbd "C-<right>") 'winner-redo)
       (("C-<prior>"     .   winner-undo)
        ("C-<next>"      .   winner-redo)
        ("C-s-j"         .   winner-undo)
        ("C-s-k"         .   winner-redo)
        ("<XF86Back>"    .   winner-undo)
        ("<XF86Forward>" .   winner-redo))
       )
  #+END_SRC

  Undo-tree
  #+BEGIN_SRC emacs-lisp
    (use-package undo-tree
      :diminish undo-tree-mode
      :config
      (global-undo-tree-mode)
       ;; autosave the undo-tree history
      (setq undo-tree-history-directory-alist
            `((".*" . ,undo-tree-directory)))
      (setq undo-tree-auto-save-history t)
      :bind (("\C-x u" . undo-tree-visualize))
      )
  #+END_SRC

  Windmode for easier moving between windows
  #+BEGIN_SRC emacs-lisp
    (use-package windmove
      :bind
      (("s-k" . windmove-up)
       ("s-h" . windmove-left)
       ("s-j" . windmove-down)
       ("s-l" . windmove-right))
    )
  #+END_SRC

  Expand region to select semantically
  #+BEGIN_SRC emacs-lisp
    ; Expand the marked region in semantic increments (negative prefix to reduce region)
    (use-package expand-region
      :bind ("C-=" . er/expand-region)
      )
  #+END_SRC

  Save recent files visited
  #+BEGIN_SRC emacs-lisp
    (use-package recentf
      :defer 4
      :bind ("C-x C-r" . counsel-recentf)
      :config
      (recentf-mode 1)
      (setq-default
       recentf-max-saved-items 1000
       recentf-exclude '("/tmp/" "/ssh:"))
      )
  #+END_SRC

  Rainbow-delimiters to have colored parantheses depending on the depth level.
  The package impacts performances, though.
  #+BEGIN_SRC emacs-lisp
    ;; (use-package rainbow-delimiters
    ;;   :hook (prog-mode . rainbow-delimiters-mode)
    ;;   )
  #+END_SRC

  Clickable addresses and web urls
  #+BEGIN_SRC emacs-lisp
      (use-package goto-addr
        :hook
        ((prog-mode . goto-address-prog-mode)
         (term-mode. goto-address-mode))
        )
  #+END_SRC
** Google C/C++ style
  #+BEGIN_SRC emacs-lisp
      (use-package google-c-style
        :hook
        ((c-mode-common . google-set-c-style)
         (c-mode-common. google-make-newline-indent))
        )
  #+END_SRC
** Whitespaces
   Whitespace configuration, stolen from Purcell
   #+BEGIN_SRC emacs-lisp
     (use-package whitespace-cleanup-mode
       :diminish whitespace-cleanup-mode
       :config
       ;; Show whitespaces
       (setq-default show-trailing-whitespace t)
       ;; Clean thitespaces
       (global-whitespace-cleanup-mode t)
       ;; Delete trailing whitespaces every time a buffer is saved
       (add-hook 'before-save-hook 'delete-trailing-whitespace)

       (defun sanityinc/no-trailing-whitespace ()
         "Turn off display of trailing whitespace in this buffer."
         (setq show-trailing-whitespace nil))

       ;; But don't show trailing whitespace in term modes, and so on
       (dolist (hook '(special-mode-hook
                       Info-mode-hook
                       eww-mode-hook
                       eshell-mode-hook
                       term-mode-hook
                       comint-mode-hook
                       compilation-mode-hook
                       ein:notebook-mode-hook
                       telega-root-mode-hook
                       telega-chat-mode-hook
                       vterm-mode-hook
                       minibuffer-setup-hook))
         (add-hook hook #'sanityinc/no-trailing-whitespace))
       ;; Cycle spacing kills every space except one the first ime
       ;; it is called, the second kills everyone
       (global-set-key [remap just-one-space] 'cycle-spacing)
       )
   #+END_SRC
** Engine-mode
   Engine-mode is a convenient way to search online directly from Emacs.
   The default keybind is C-x /
   #+BEGIN_SRC emacs-lisp
     (use-package engine-mode
       :config
       (engine-mode t)

       ;; It seems that somewhere the value is overwritten
       (setq engine/browser-function 'browse-url-chromium-app)

       (defengine ads-abs
         "http://adsabs.harvard.edu/cgi-bin/basic_connect?qsearch=%s&version=1"
         :keybinding "a")

       (defengine duckduckgo
         "https://duckduckgo.com/?q=%s"
         :keybinding "d")

       (defengine google
         "https://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
         :keybinding "g")

       (defengine merriam-webster
         "https://www.merriam-webster.com/dictionary/%s"
         :keybinding "m")

       (defengine merriam-webster-thesaurus
         "https://www.merriam-webster.com/thesaurus/%s"
         :keybinding "t")

       )
   #+END_SRC
** TRAMP
   Use controlmaster to use always the same ssh socket.
   #+BEGIN_SRC emacs-lisp
    (use-package tramp
      :init
      (setq tramp-ssh-controlmaster-options
            (substitute-in-file-name (concat
                                      "-o ControlPath=$HOME/.ssh/ssh-%%r@%%h:%%p "
                                      "-o ControlMaster=auto -o ControlPersist=yes")))
      (setq tramp-default-method "ssh")
      :config
      ;; Use $PATH of the remote machine
      (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
      (setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*")
    )
   #+END_SRC
** Sessions
   #+BEGIN_SRC emacs-lisp
    (use-package session
      :init
      (add-hook 'after-init-hook 'session-initialize)
      :config
      ;; save a list of open files in ~/.emacs.d/.emacs.desktop
      (setq desktop-path (list user-emacs-directory)
            desktop-auto-save-timeout 600
            desktop-restore-frames nil)
      (setq-default history-length 1000)
      (savehist-mode t)
      ;; save a bunch of variables to the desktop file
      ;; for lists specify the len of the maximal saved data also
      (setq desktop-globals-to-save
            (append '((comint-input-ring        . 50)
                      (compile-history          . 30)
                      desktop-missing-file-warning
                      (dired-regexp-history     . 20)
                      (extended-command-history . 30)
                      (face-name-history        . 20)
                      (file-name-history        . 100)
                      (grep-find-history        . 30)
                      (grep-history             . 30)
                      (ido-buffer-history       . 100)
                      (ido-last-directory-list  . 100)
                      (ido-work-directory-list  . 100)
                      (ido-work-file-list       . 100)
                      (ivy-history              . 100)
                      (magit-read-rev-history   . 50)
                      (minibuffer-history       . 50)
                      (org-clock-history        . 50)
                      (org-refile-history       . 50)
                      (org-tags-history         . 50)
                      (query-replace-history    . 60)
                      (read-expression-history  . 60)
                      (regexp-history           . 60)
                      (regexp-search-ring       . 20)
                      register-alist
                      (search-ring              . 20)
                      (shell-command-history    . 50)
                      tags-file-name
                      tags-table-list)))

      (setq session-save-file (expand-file-name ".session" user-emacs-directory))
      (setq session-name-disable-regexp "\\(?:\\`'/tmp\\|\\.git/[A-Z_]+\\'\\)")
      )
   #+END_SRC
** Flycheck
   #+BEGIN_SRC emacs-lisp
     ;; (use-package flycheck
     ;;   :defer 7
     ;;   :hook
     ;;   (prog-mode . flycheck-mode)
     ;;   :config (progn
     ;;             (setq flycheck-check-syntax-automatically '(save mode-enabled))
     ;;             (setq flycheck-standard-error-navigation nil)
     ;;             ;; flycheck errors on a tooltip (doesn't work on console)
     ;;             (when (display-graphic-p (selected-frame))
     ;;               (eval-after-load 'flycheck
     ;;                 '(custom-set-variables
     ;;                   '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))
     ;;               ))
     ;; (use-package flycheck-pos-tip
     ;;   :after flycheck
     ;;   )
     ;;   )
   #+END_SRC
** ggtags
   #+BEGIN_SRC emacs-lisp
     (use-package ggtags
       :ensure t
       :defer t
       :hook
       (c-mode-common-hook .
                 (lambda ()
                   (when (derived-mode-p 'c-mode 'c++-mode)
                     (ggtags-mode 1))))
       )
   #+END_SRC
** Company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :init   (global-company-mode)
       :diminish company-mode
       )

     ;; (use-package company
     ;;   :init   (global-company-mode)
     ;;   :config

     ;;   ;; Ignore some file
     ;;   (setq completion-ignored-extensions
     ;;         '(".o" ".elc" "~" ".bin" ".class" ".exe" ".ps" ".abs" ".mx"
     ;;           ".~jv" ".rbc" ".pyc" ".beam" ".aux" ".out" ".pdf" ".hbc"))

     ;;   (setq company-transformers '(company-sort-by-occurrence)) ; weight by frequency

     ;;   (setq completion-cycle-threshold 5)

     ;;   ;; To have completion with TAB
     ;;   (setq tab-always-indent 'complete)
     ;;   ;; Do not wait!
     ;;   (setq company-idle-delay 0)

     ;;   (add-to-list 'completion-styles 'initials t)

     ;;   (setq-default company-dabbrev-other-buffers 'all
     ;;                 company-tooltip-align-annotations t)

     ;;   ;; ;; Documentation popups for Company
     ;;   ;; (use-package company-quickhelp
     ;;   ;;   :defer t
     ;;   ;;   :after company
     ;;   ;;   :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode))

     ;;   ;; (use-package company-c-headers
     ;;   ;;   :diminish company-c-headers
     ;;   ;;   :defer t
     ;;   ;;   :after company
     ;;   ;;   :config
     ;;   ;;   (add-to-list 'company-backends 'company-c-headers)
     ;;   ;;   )

     ;;   :diminish company-mode
     ;;   :bind  (:map company-active-map
     ;;                ("C-n" . company-select-next)
     ;;                ("C-p" . company-select-previous)
     ;;                ("M-/" . company-other-backend))

     ;;   )

     ;; ;; (with-eval-after-load 'company
     ;; ;;   (add-hook 'c++-mode-hook 'company-mode)
     ;; ;;   (add-hook 'c-mode-hook 'company-mode))

     ;; ;; (use-package company-irony
     ;; ;;   :defer  t
     ;; ;;   :after company
     ;; ;;   :config
     ;; ;;     (setq-local company-backends '((company-etags
     ;; ;;                                     company-dabbrev-code
     ;; ;;                                     company-c-headers
     ;; ;;                                     company-irony))))
     ;; ;; ; Remember irony-install-server
     ;; ;; (use-package irony
     ;; ;;   :defer t
     ;; ;;   :after company
     ;; ;;   :config
     ;; ;;     (add-hook 'c++-mode-hook 'irony-mode)
     ;; ;;     (add-hook 'c-mode-hook 'irony-mode)
     ;; ;;     (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

     ;; (use-package company-statistics         ; Show likelier candidates on top
     ;;   :defer t
     ;;   :after company
     ;;   :config (company-statistics-mode))

     ;; (with-eval-after-load 'company
     ;;     (add-hook 'python-mode-hook 'company-mode))

     ;; (defun python-mode-company-init ()
     ;;   (setq-local company-backends '((company-jedi
     ;;                                   company-etags
     ;;                                   company-dabbrev-code))))

     ;; (use-package company-jedi
     ;;   :defer t
     ;;   :after company
     ;;   :init
     ;;   (add-hook 'python-mode-hook '(lambda () (interactive) (add-to-list 'company-backends 'company-jedi)))
     ;;   :config
     ;;   (add-hook 'python-mode-hook 'jedi:setup)
     ;;   (add-hook 'python-mode-hook 'company-mode)
     ;;   (add-hook 'python-mode-hook 'python-mode-company-init)
     ;;   )

     ;; (use-package company-shell              ; Company support for shell functions
     ;;   :defer t
     ;;   :after company
     ;;   :config
     ;;   ;;All the executables in my $PATH
     ;;   (add-to-list 'company-backends 'company-shell)
     ;;   ;;All the executables in env
     ;;   (add-to-list 'company-backends 'company-shell-env))
   #+END_SRC
** Ivy and friends
   #+BEGIN_SRC emacs-lisp
       ;; Ivy and counsel instead of IDO
       (use-package ivy
         :diminish ivy-mode
         :bind
         (("C-x b" . ivy-switch-buffer)
          ("C-s" . counsel-grep-or-swiper)
          ("C-r" . swiper)
          :map ivy-minibuffer-map
          ("C-j" . ivy-immediate-done)
          ("RET" . ivy-alt-done)
          )
         :init
         :config
         (ivy-mode 1)
         (setq counsel-grep-swiper-limit (* 1024 100000))
         (setq conusel-grep-base-command "grep -i -E -n -e %s %s")
         (setq-default ivy-use-virtual-buffers t
                       ivy-count-format ""
                       ivy-display-style 'fancy
                       projectile-completion-system 'ivy
                       ivy-initial-inputs-alist
                       '((counsel-M-x . "^")
                         (man . "^")
                         (woman . "^")))
         ;; Press C-p to select an item, then press RET to return it
         ;; (For example when renaming files with the same name)
         (setq ivy-use-selectable-prompt t)
         )

       (use-package counsel
         :diminish counsel-mode
         :ensure ivy
         :init
         (setq-default counsel-mode-override-describe-bindings t)
         (add-hook 'after-init-hook 'counsel-mode)
         :bind
         (("M-x" . counsel-M-x)
          ("C-x C-f" . counsel-find-file)
          ("M-y" . counsel-yank-pop)
          ("C-h d" . counsel-apropos)
          :map ivy-minibuffer-map   ("M-y" . ivy-next-line)
          )
         )

     (use-package counsel-tramp          ; Ivy interface for SSH via TRAMP
       :bind ("C-c a t t" . counsel-tramp))
   #+END_SRC
** Flyspell
   #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :defer 6
      :hook
      ((flyspell-mode . (lambda () (define-key
                                            flyspell-mode-map (kbd "C-c $") nil)))
      ;;Checking spell in comments and string
      (c-mode . flyspell-prog-mode)
      (sh-mode . flyspell-prog-mode)
      (c++-mode . flyspell-prog-mode)
      (python-mode . flyspell-prog-mode)
      (makefile-mode . flyspell-prog-mode)
      (emacs-lisp-mode . flyspell-prog-mode))
      :config
      ;; Use hunspell
      (setq ispell-program-name "hunspell")
      ;; With a dictionary in my home
      (setq ispell-personal-dictionary (substitute-in-file-name "$HOME/.emacs.d/hunspell_dict.txt"))

      (defun instant-save-word ()
        "Add the word around the point to the personal dictionary
    defined in ispell-personal-dictionary without asking"
        (interactive)
        (let ((current-location (point))
              (word (flyspell-get-word)))
          (when (consp word)
            (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location))))
       :bind
       (("C-c $" . instant-save-word))
      )
   #+END_SRC
* Major-modes
  In some cases I set mode explicitly even if it is not necessary.



  This is for Ledger for personal finances
  #+BEGIN_SRC emacs-lisp
    (use-package ledger-mode
      :mode (("\\.ledger\\'" . ledger-mode))
      :bind (:map ledger-mode-map
      ("C-c C-z" .  (lambda () (interactive) (progn (ledger-sort-buffer) (ledger-mode-clean-buffer))))
      )
      )
  #+END_SRC


  #+BEGIN_SRC emacs-lisp
  (use-package helpful                    ; A better *help* buffer
  :ensure t
  :bind (("C-c p" . helpful-at-point)
         ("C-h f" . helpful-callable)
         ("C-h C" . helpful-command)
         ("C-h F" . helpful-function)
         ("C-h k" . helpful-key)
         ("C-h v" . helpful-variable)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package browse-url                 ; Browse URLs
      :bind
      (
       ("C-x / b" . sbozzolo/browse-url)
       ("C-c g c" . (lambda () (interactive) (browse-url "https://calendar.google.com/calendar/b/1/r")))
       )
      :config

      (defun sbozzolo/browse-url (url)
        "Browse url starting with what is at the point"
        (interactive (list
                      (read-string (format "URL (%s): " (thing-at-point 'url))
                                   (thing-at-point 'url) nil (thing-at-point 'url))))
        (browse-url url))

      (setq browse-url-browser-function 'browse-url-chromium-app)

      ;; This is to have a full screen chromium using the "-app="
      ;; trick. Apparently it works only if the protocol is specified
      (defun browse-url-chromium-app (url &optional _new-window)
        "Ask the Chromium WWW browser to load URL.
        Default to the URL around or before point.  The strings in
        variable `browse-url-chromium-arguments' are also passed to
        Chromium.
        The optional argument NEW-WINDOW is not used."
        (interactive (browse-url-interactive-arg "URL: "))
        (setq url (browse-url-encode-url url))
        ;; Check if url starts with http:// or https://, if not add it
        (unless
            (or (equal (substring url 0 7) "file://")
                (equal (substring url 0 7) "http://")
                (equal (substring url 0 8) "https://"))
          (setq url (concat "http://" url))
          )
        (let* ((process-environment (browse-url-process-environment)))
          (apply 'start-process
                 url nil
                 browse-url-chromium-program
                 (append
                  browse-url-chromium-arguments
                  (list (concat "--app=" url))))))
      )
  #+END_SRC

  Mathematica
  #+BEGIN_SRC emacs-lisp
    (use-package wolfram-mode
      :mode (("\\.math\\'" . wolfram-mode)
             ("\\.nb\\'"   . wolfram-mode)
             ("\\.m\\'"    . wolfram-mode))
      )
  #+END_SRC

  Systemd to edit systemd units.
  #+BEGIN_SRC emacs-lisp
    (use-package systemd
      :mode (("\\.timer\\'"   . systemd-mode)
             ("\\.service\\'" . systemd-mode))
      )
  #+END_SRC

  CMake files
  #+BEGIN_SRC emacs-lisp
    (use-package cmake-mode
      )
  #+END_SRC


  Edit dockerfile
  #+BEGIN_SRC emacs-lisp
    (use-package dockerfile-mode
      :mode (("\\.Dockerfile\\'" . dockerfile-mode))
      )
  #+END_SRC

  Edit yaml
  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode
      :mode (("\\.yaml\\'" . yaml-mode))
      )
  #+END_SRC

  Editable grep buffers
  #+BEGIN_SRC emacs-lisp
    (use-package wgrep
      :defer t
      )
  #+END_SRC

  Emacs interface to GNU pass for password storing.
  When using EXWM pinentry-curses must not be used!
  #+BEGIN_SRC emacs-lisp
    (use-package pass
      :defer t
      :config
         (define-key pass-mode-map (kbd "q") (lambda () (interactive)
                           (progn
                            (dolist (buf (buffer-list))
                              (with-current-buffer buf
                                (when (eq major-mode 'pass-view-mode)
                                  (kill-buffer buf))))
                                   (quit-window t)
                            )
                           ))
                   )
    (use-package ivy-pass
      :defer t
      )
  #+END_SRC

  System monitor, it doesn't work if the minibuffer is hidden
  #+BEGIN_SRC emacs-lisp
    (use-package symon
       :bind
       ("C-M-h" . symon-mode)
       :config
       (when (setq exwm-workspace-minibuffer-position 'bottom) (exwm-workspace-attach-minibuffer))
       )
  #+END_SRC

  Paraedit for lisp editing and ielm for debugging.
  I wish I knew how to use it.
  #+BEGIN_SRC emacs-lisp
    ;; (use-package paredit
    ;;   :hook
    ;;   ((emacs-lisp-mode . paredit-mode)
    ;;   ;; enable in the *scratch* buffer
    ;;   (isp-interaction . paredit-mode)
    ;;   (ielm-mode-hook . paredit-mode)
    ;;   (lisp-mode-hook . paredit-mode)
    ;;   (eval-expression-minibuffer . paredit-mode))
    ;;   )
  #+END_SRC

  Gitignore
  #+BEGIN_SRC emacs-lisp
    (use-package gitignore-mode
      :mode (("\\.gitignore\\'" . gitignore-mode))
      :hook
      (gitignore-mode . (lambda () (setq require-final-newline t)))
    )
  #+END_SRC

  Markdown mode for markdown (eg. Hugo)
  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :mode (("\\.md\\'" . markdown-mode))
      )
  #+END_SRC

  Emacs iPython (Jupyter) Notebook
  #+BEGIN_SRC emacs-lisp
    ;; (use-package ein
    ;;   :config
    ;;   ;; [TODO] Figure out how to use a sensible auto-completion
    ;;   (setq ein:use-auto-complete t)
    ;;   (setq ein:completion-backend 'ein:use-ac-jedi-backend)
    ;;   (setq ein:jupyter-default-server-command "/usr/bin/jupyter"
    ;;                  ein:jupyter-server-args (list "--no-browser")
    ;;                  )
    ;;   )
  #+END_SRC

  Some sh-like files
  #+BEGIN_SRC emacs-lisp
    (use-package sh-script
      :mode (("\\.ebuild\\'" . sh-mode)
             ;Einstein Toolkit
             ("\\.th\\'" . sh-mode)
             ("\\.ccl\\'" . sh-mode)
             ("\\.par\\'" . sh-mode))
      )
  #+END_SRC

  Dired (TODO Move the use-package!)
  #+BEGIN_SRC emacs-lisp
     (setq
      dired-listing-switches "-alh" ;; Human readable size in dired
      dired-dwim-target t ;; Dired do what I mean, to move files more easily
      )
     ;; always delete and copy recursively
     (setq dired-recursive-deletes 'always
           dired-recursive-copies 'always
           )
  #+END_SRC

  Ibuffer is a convenient way to manage open buffers
  #+BEGIN_SRC emacs-lisp
    (use-package ibuffer
      :commands (ibuffer)
      :bind (([remap list-buffers] . ibuffer))
      )
  #+END_SRC

  C programming
  #+BEGIN_SRC emacs-lisp
    ;; Compile with C-x C-m (C-m)
    (use-package cc-mode
      :bind ("C-x C-m" . compile)
    )
  #+END_SRC

  Julia programming
  #+BEGIN_SRC emacs-lisp
    (use-package julia-mode
      :mode (("\\.jl\\'" . julia-mode))
    )
  #+END_SRC

  Magit
  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :config
      (setq magit-display-buffer-function
            (lambda (buffer)
              (display-buffer
               buffer (if (and (derived-mode-p 'magit-mode)
                               (memq (with-current-buffer buffer major-mode)
                                     '(magit-process-mode
                                       magit-revision-mode
                                       magit-diff-mode
                                       magit-stash-mode
                                       magit-status-mode)))
                          nil
                        '(display-buffer-same-window)))))
      ;;(setq magit-commit-arguments (quote ("--gpg-sign=bozzola.gabriele@gmail.com")))
      :bind (("\C-x g" . magit-status))
      )
  #+END_SRC

  Google translate on the fly :)
  #+BEGIN_SRC emacs-lisp
  ;; Google translate
  (use-package google-translate
    :init (setq google-translate-translation-directions-alist '(("it" . "en") ("en" . "it")))
    :config
    (require 'google-translate-smooth-ui)
    :bind (("\C-ct" . google-translate-smooth-translate))
   )
  #+END_SRC
  Define word
  #+BEGIN_SRC emacs-lisp
    (use-package define-word
      :bind (("\C-c d" . sbozzolo/define-word))
      :config
      ;; Small tweak so that the default behavior is to suggest what is under the point
      (defun sbozzolo/define-word (word)
        "Make define-word suggest the word at point"
        (interactive (list
                      (read-string (format "Word (%s): " (thing-at-point 'word))
                                   (thing-at-point 'word) nil (thing-at-point 'word))))
        (define-word word define-word-default-service))
      )
  #+END_SRC
** Pdftools
   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :magic ("%PDF" . pdf-view-mode)
       :mode (("\\.pdf\\'" . pdf-view-mode))
     ;; Don't use swyper in pdf-tools
       :bind (:map pdf-view-mode-map
                   ("C-s" . isearch-forward)
                   ("C-r" . isearch-backward)
                   ("g"   . my-revert-pdf)
             )
       :config
       (pdf-tools-install :no-query)

       (setq-default pdf-view-display-size 'fit-page)

       ;; Sync tex and pdf
       (defun th/pdf-view-revert-buffer-maybe (file)
         (let ((buf (find-buffer-visiting file)))
           (when buf
             (with-current-buffer buf
               (when (derived-mode-p 'pdf-view-mode)
                 (pdf-view-revert-buffer nil t))))))
       (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
                 #'th/pdf-view-revert-buffer-maybe)


       (defun kill-file-associated-buffer-and-reopen-file ()
         "Kill the buffer if its file associated, and reopen the file."
         (let ((file buffer-file-name))
           (when file
             (kill-buffer)
             (find-file file))))

       (defun my-revert-pdf ()
         "Revert if local. Kill and reopen if remote."
         (interactive)
         (cond
          ;; If remote kill buffer and reopen.
          ((file-remote-p buffer-file-name)
           (kill-file-associated-buffer-and-reopen-file))
          ;; If not remote, just revert
          (t (revert-buffer))))
       )
   #+END_SRC
** Multi-term
   #+BEGIN_SRC emacs-lisp
     (use-package eterm-256color
       :hook  (term-mode . eterm-256color-mode)
       )

     ;; Some terminal functions
     (defun last-term-buffer (l)
       "Return most recently used term buffer."
       (when l
         (if (eq 'term-mode (with-current-buffer (car l) major-mode))
             (car l) (last-term-buffer (cdr l)))))

     (defun get-term ()
       "Switch to the term buffer last used, or create a new one if
         none exists, or if the current buffer is already a term."
       (interactive)
       (let ((b (last-term-buffer (buffer-list))))
         (if (or (not b) (eq 'term-mode major-mode))
             (multi-term)
           (switch-to-buffer b))))

     ;; Better paste
     (defun my/term-paste (&optional string)
       "Paste on terminals"
       (interactive)
       (process-send-string
        (get-buffer-process (current-buffer))
        (if string string (current-kill 0))))

     (use-package multi-term
       :init
       ;; Fix encoding
       (defadvice multi-term (after advise-multi-term-coding-system)
         (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
       (ad-activate 'multi-term)
       :bind (:map term-raw-map
                   ("C-y" . my/term-paste)
                   )
       :config
       (setq multi-term-program "/bin/zsh")

       ;; It would be nice to find a more compact way using remove and add-to-list

       (setq term-bind-key-alist
             '(("C-c C-c" . term-interrupt-subjob)
               ("C-c C-j" . term-line-mode)
               ("C-c C-e" . term-send-esc)
               ("C-p" . previous-line)
               ("C-n" . next-line)
               ("C-m" . term-send-return)
               ("C-y" . term-paste)
               ("M-f" . term-send-forward-word)
               ("M-b" . term-send-backward-word)
               ("M-o" . term-send-backspace)
               ("M-p" . term-send-up)
               ("M-n" . term-send-down)
               ("M-M" . term-send-forward-kill-word)
               ("M-N" . term-send-backward-kill-word)
               ("<C-backspace>" . term-send-backward-kill-word)
               ("C-r" . term-send-reverse-search-history)
               ("M-d" . term-send-delete-word)
               ("M-," . term-send-raw)
               ("M-." . comint-dynamic-complete)))

       ;; On shells, please handle properly the ansi escape codes
       (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
       (add-hook 'term-mode-hook 'ansi-color-for-comint-mode-on)

       ;; (setq term-scroll-to-bottom-on-input t
       ;;   term-scroll-to-bottom-on-output nil
       ;;   term-scroll-show-maximum-output nil)
       )
   #+END_SRC
** AucTeX
   #+BEGIN_SRC emacs-lisp
     (use-package tex-site
       :ensure auctex
       :defines (latex-help-cmd-alist latex-help-file)
       :mode (("\\.tikz\\'" . LaTeX-mode))
       :config
       (setq reftex-plug-into-AUCTeX t)
       ;; Turn on RefTeX in AUCTeX
       (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
       ;; Enable always math mode
       (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
       ;; Enable flyspell for spell checking
       (add-hook 'LaTeX-mode-hook 'flyspell-mode)
       ;; Electric $ $
       (add-hook 'LaTeX-mode-hook
                 (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
                            (cons "$" "$"))))
       ;; Don't insert braces after symbols in math mode
       (setq TeX-insert-braces nil)


       (setq reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource"))

       ;; Use pdftools
       (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
       (setq TeX-view-program-list '(("PDF Tools" "TeX-pdf-tools-sync-view")))
       (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

       (setq font-latex-script-display (quote ((raise -0.2) raise 0.2)))

       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\colon" . ?:) prettify-symbols-alist)))
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\percent" . ?%) prettify-symbols-alist)))
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\pm" . ?±) prettify-symbols-alist)))
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\dots" . ?…) prettify-symbols-alist)))
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\rrbracket" . 10215) prettify-symbols-alist))) ;;;⟧
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\llbracket" . 10214) prettify-symbols-alist))) ;;;⟦
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\incl" . ?↪) prettify-symbols-alist)))
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\slash" . ?/) prettify-symbols-alist)))
       (add-hook 'LaTeX-mode-hook
                 (lambda ()
                   (push '("\\bigcup" . ?⋃) prettify-symbols-alist)))

       ;; Personal bindings in math mode
       (setq LaTeX-math-list '(
                               (?, "partial" "Misc Symbol" 8706)
                               (?% "percent" "Misc Symbol" 0025)
                               ;; Not using them anymore...
                               ;; (?o "circ" "Binary Operator" 9675)
                               ;; (?= "cong" "Binary Operator" 2265)
                               ))

       (setq TeX-parse-self t)
       (setq TeX-auto-save t)
       (setq-default TeX-master nil)

       ;; Disable prompt for reference format
       (setq reftex-ref-macro-prompt nil)

       ;;Enable SyncTex
       (setq TeX-source-correlate-mode t)

       ;; Nice stuff stolen from https://thenybble.de/projects/inhibit-auto-fill.html

       ;; Whitelist some autofill envs
       (defcustom LaTeX-inhibited-auto-fill-environments
         '("tabular" "tikzpicture") "For which LaTeX environments not to run auto-fill.")

       (defun LaTeX-limited-auto-fill ()
         (let ((environment (LaTeX-current-environment)))
           (when (not (member environment LaTeX-inhibited-auto-fill-environments))
             (do-auto-fill))))

       ;; (add-hook 'LaTeX-mode-hook
       ;;           (lambda () (setq auto-fill-function #'LaTeX-limited-auto-fill)) t)

       ;; Do not break the unbreakable space
       (defun LaTeX-dont-break-on-nbsp ()
         (and (eq major-mode 'latex-mode)
              (eq (char-before (- (point) 1)) ?\\)))
       (add-to-list 'fill-nobreak-predicate #'LaTeX-dont-break-on-nbsp)

       ;; Better align tables
       (defun LaTeX-collapse-table ()
         (interactive)
         (save-excursion
           (LaTeX-mark-environment)
           (while (re-search-forward "[[:space:]]+\\(&\\|\\\\\\\\\\)" (region-end) t)
             (replace-match " \\1"))))

       (defun LaTeX-align-environment (arg)
         (interactive "P")
         (if arg
             (LaTeX-collapse-table)
           (save-excursion
             (LaTeX-mark-environment)
             (align (region-beginning) (region-end)))))

       ;; (add-hook LaTeX-mode-hook
       ;;           (lambda () (local-set-key (kbd "C-c f") #'LaTeX-align-environment)))


       ;; Escape underscore
       (defun LaTeX-underscore-maybe (arg)
         (interactive "p")
         (if (eq last-command 'LaTeX-underscore-maybe)
             (progn
               (delete-backward-char 2)
               (self-insert-command 1))
           (if (or (or (> 1 arg) (texmathp)))
               (self-insert-command 1)
             (insert "\\_"))))
       ;; (add-hook LaTeX-mode-hook (lambda () (local-set-key (kbd "_") #'LaTeX-underscore-maybe)))

       (add-to-list 'fill-nobreak-predicate #'LaTeX-dont-break-on-nbsp)

       (defun LaTeX-init-tweaks ()
         (local-set-key (kbd "_") #'LaTeX-underscore-maybe)
         (local-set-key (kbd "C-c f") #'LaTeX-align-environment)
         (setq auto-fill-function #'LaTeX-limited-auto-fill))

       (add-to-list 'LaTeX-mode-hook 'LaTeX-init-tweaks)

       (add-hook 'LaTeX-mode-hook 'my-inhibit-global-company-mode)

       (defun my-inhibit-global-company-mode ()
         "Counter-act `global-company-mode'."
         (add-hook 'after-change-major-mode-hook
                   (lambda () (company-mode 0))
                   :append :local))


  (defun latex-help-get-cmd-alist ()    ;corrected version:
    "Scoop up the commands in the index of the latex info manual.
   The values are saved in `latex-help-cmd-alist' for speed."
    ;; mm, does it contain any cached entries
    (if (not (assoc "\\begin" latex-help-cmd-alist))
        (save-window-excursion
          (setq latex-help-cmd-alist nil)
          (Info-goto-node (concat latex-help-file "Command Index"))
          (goto-char (point-max))
          (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
            (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                  (value (buffer-substring (match-beginning 2)
                                           (match-end 2))))
              (add-to-list 'latex-help-cmd-alist (cons key value))))))
    latex-help-cmd-alist)


       )
   #+END_SRC
** Org-mode
   Make sure org and org-archive are open with org-mode
   #+BEGIN_SRC emacs-lisp
          (use-package org
                                                  ;:pin org
            :mode (("\\.org\\'"         . org-mode)
                   ("\\.org_archive\\'" . org-mode))
            :init
            ;;Org capture
            (setq org-directory (expand-file-name "~/documents/orgs"))
            (setq
             org-todo-file (concat org-directory "/todo.org")
             org-projects-file (concat org-directory "/projects.org")
             org-scheduled-file (concat org-directory "/schedule.org")
             org-links-file (concat org-directory "/links.org")
             org-lists-file (concat org-directory "/lists.org")
                                                  ;org-goals-file (concat org-directory "/goals.org")
                                                  ;org-ideas-file (concat org-directory "/ideas.org")
                                                  ;org-money-file (concat org-directory "/2019.ledger")
             org-books-file (concat org-directory "/books.org")
             org-films-file (concat org-directory "/films.org")
             ;;org-papers-file (concat org-directory "/papers.org")
                                                  ;org-wishlists-file (concat org-directory "/wishlists.org")
             org-workout-file (concat org-directory "/workout.org")
             org-gcal-file (concat org-directory "/gcal.org")
             )
            :bind (("\C-c a" . org-agenda))
            :config
            (use-package org-bullets
              :after org
              :defer t
              :hook
              (org-mode . (lambda () (org-bullets-mode t)))
              )

            (add-to-list 'org-modules 'org-habit)

            ;; Copied from reddit
            ;; https://old.reddit.com/r/emacs/comments/8gbopk/tip_how_to_speed_up_your_emacs_config_by_03/
            (defvar *config-file* "/home/sbozzolo/dotfiles/emacs/.emacs.d/settings.org"
              "The configuration file.")

            (defvar *config-last-change* (nth 5 (file-attributes *config-file*))
              "Last modification time of the configuration file.")

            (defvar *show-async-tangle-results* nil
              "Keep *emacs* async buffers around for later inspection.")

            (defun my/config-updated ()
              "Check if the configuration file has been updated since the last time."
              (time-less-p *config-last-change*
                           (nth 5 (file-attributes *config-file*))))

            (defun my/config-tangle ()
              "Tangle the org file asynchronously."
              (when (my/config-updated)
                (setq *config-last-change*
                      (nth 5 (file-attributes *config-file*)))
                (my/async-babel-tangle *config-file*)))

            (defun my/async-babel-tangle (org-file)
              "Tangle the org file asynchronously."
              (let ((init-tangle-start-time (current-time))
                    (file (buffer-file-name))
                    (async-quiet-switch "-q"))
                (async-start
                 `(lambda ()
                    (require 'org)
                    (org-babel-tangle-file ,org-file))
                 (unless *show-async-tangle-results*
                   `(lambda (result)
                      (if result
                          (message "SUCCESS: %s successfully tangled (%.2fs)."
                                   ,org-file
                                   (float-time (time-subtract (current-time)
                                                              ',init-tangle-start-time)))
                        (message "ERROR: %s as tangle failed." ,org-file)))))))

            (add-hook 'after-save-hook #'(lambda () (interactive)
                                           (when (string= "settings.org" (buffer-name))
                                             (my/config-tangle)
                                             )))

            ;;Print timestamp when done
            (setq org-log-done t)

            ;; Cuter bullets
            (setq org-ellipsis "⤵")

            ;; Syntax highlighting in source blocks
            (setq org-src-fontify-natively t)

            ;; Hide markers when text is markup
            (setq org-hide-emphasis-markers t)

            ;; Don't ask for confirmation
            (setq org-confirm-babel-evaluate nil)

            ;; Refile to agenda files
            (setq org-refile-use-outline-path 'file)
            (setq org-outline-path-complete-in-steps nil)
            (setq org-refile-targets '(("~/documents/orgs/schedule.org" . (:maxlevel . 2))
                                       ("~/documents/orgs/projects.org" . (:maxlevel . 1))
                                       ("~/documents/orgs/lists.org"    . (:maxlevel . 1))
                                       ))

            (setq org-agenda-files '("~/documents/orgs/schedule.org"
                                     "~/documents/orgs/todo.org"
                                     "~/documents/orgs/projects.org"
                                     "~/documents/orgs/gcal.org"))

            (use-package org-gcal
              :ensure t
              :config
              (setq org-gcal-client-id     sbozzolo-org-gcal-client-id
                    org-gcal-client-secret sbozzolo-org-gcal-client-secret
                    org-gcal-file-alist '(("bozzola.gabriele@gmail.com" .  "~/documents/orgs/gcal.org")))

              ;; Function to refresh the calendar when internet is available
              (defun fetch-calendar ()
                (when (internet-up-p) (org-gcal-fetch)))

              :hook
              (org-agenda . (lambda () (fetch-calendar)))
              )

            (setq org-agenda-custom-commands
                  '(("c" "Simple agenda view"
                     ((agenda "")
                      (alltodo "")))))

            ;; From https://stackoverflow.com/questions/22394394/orgmode-a-report-of-tasks-that-are-done-within-the-week
            ;; define "R" as the prefix key for reviewing what happened in various
            ;; time periods
            (add-to-list 'org-agenda-custom-commands
                         '("R" . "Review" )
                         )

            ;; Common settings for all reviews
            (setq efs/org-agenda-review-settings
                  '(
                    (org-agenda-show-all-dates t)
                    (org-agenda-start-with-log-mode t)
                    (org-agenda-archives-mode t)
                    ;; I don't care if an entry was archived
                    (org-agenda-hide-tags-regexp
                     (concat org-agenda-hide-tags-regexp
                             "\\|ARCHIVE"))
                    ))
            ;; Show the agenda with the log turn on, the clock table show and
            ;; archived entries shown.  These commands are all the same exept for
            ;; the time period.
            (add-to-list 'org-agenda-custom-commands
                         `("Rd" "Day in review"
                           agenda ""
                           ;; agenda settings
                           ,(append
                             efs/org-agenda-review-settings
                             '((org-agenda-span 'day)
                               (org-agenda-overriding-header "Day in Review"))
                             )
                           ))

            (add-to-list 'org-agenda-custom-commands
                         `("Rw" "Week in review"
                           agenda ""
                           ;; agenda settings
                           ,(append
                             efs/org-agenda-review-settings
                             '((org-agenda-span 'week)
                               (org-agenda-start-on-weekday 0)
                               (org-agenda-overriding-header "Week in Review"))
                             )
                           ))


            ;; active Babel languages
                                                  ;(org-babel-do-load-languages
                                                  ; 'org-babel-load-languages
                                                  ; '((emacs-lisp . t)
                                                  ;   (ledger . t)
                                                  ;   ))

            ;; Don't open babel src editor in a new window
            (setq org-src-window-setup 'current-window)

            ;; Unbind keys I have defined elsewhere
            (define-key org-mode-map (kbd "C-a") nil)
            (define-key org-mode-map (kbd "RET") nil)

            ;;  Org reval for reveal.js presentations

            ;; (use-package ox-reveal
            ;;   :ensure ox-reveal
            ;;   :config
            ;;   (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
            ;;   (setq org-reveal-mathjax t)
            ;;   )

            (use-package ox-hugo)

            ;; (use-package htmlize
            ;;   )

            ;;Org-tree-slide for presentations within emacs
            ;; (use-package org-tree-slide
            ;;   :init
            ;;   (define-key org-mode-map (kbd "<f8>") 'org-tree-slide-mode)
            ;;   :bind
            ;;   (:map org-tree-slide-mode-map
            ;;         ("<f9>" . org-tree-slide-move-previous-tree)
            ;;         ("<f10>" . org-tree-slide-move-next-tree)
            ;;         :map org-mode-map
            ;;         ("<f8>" . org-tree-slide-mode)
            ;;         )
            ;;   )

            (setq org-todo-keywords
                  (quote ((sequence "PROJECT(p)" "TODO(t)" "WAITING(w@/!)" "|" "DONE(d!/!)" "CANCELLED(c@/!)")))
                  org-todo-repeat-to-state "TODO")

            (setq org-archive-mark-done nil)
            (setq org-archive-location "%s_archive::* Archive")
                                                  ;Save archive
            (add-hook 'auto-save-hook 'org-save-all-org-buffers)

            (setq org-todo-keyword-faces
                  (quote (("NEXT" :inherit warning)
                          ("PROJECT" :inherit font-lock-string-face))))

            (setq org-capture-templates
                  '(
                    ("t" "Inbox" entry (file org-todo-file)
                     "** TODO %^{TODO}\n :PROPERTIES:\n :CREATED:   %U \n :END:"
                     :immediate-finish t)
                    ;; ("l" "Links" entry (file org-links-file)
                    ;;  "* %? [[%x][%^{Description}]] %^g\n :PROPERTIES:\n :CREATED:   %U \n :END:"
                    ;;  :immediate-finish t)
                    ;; ("p" "Papers" entry (file org-papers-file)
                    ;;  "* %? [[%x][%^{Description}]] %^g\n :PROPERTIES:\n :CREATED:   %U \n :END:"
                    ;;  :immediate-finish t)
                    ;; ("w" "Whishlist")
                    ;; ("wi" "Whishlist Items" entry (file+headline org-wishlists-file "Items")
                    ;;  "** TODO %^{Item} %?  \n   Entered on %U"
                    ;;  :immediate-finish t)
                    ;; ("wb" "Whishlist Books" entry (file+headline org-wishlists-file "Books")
                    ;;  "** TODO %^{Book} %?  \n   Entered on %U"
                    ;;  :immediate-finish t)
                    ;; ("wf" "Whishlist Films" entry (file+headline org-wishlists-file "Films")
                    ;;  "** TODO %^{Film} %? \n   Entered on %U"
                    ;;  :immediate-finish t)
                    ;; ("W" "Workout")
                    ;; ("Wr" "Workout Rest" entry (file org-workout-file)
                    ;;  "* %u\n** Rest\n   %?")
                    ;; ("Wg" "Workout Gym" entry (file org-workout-file)
                    ;;  "* %u\n** Running\n   *Time*: %^{Running Time} min\n   *Velocity*: %^{Running Velocity} km/h\n   *Length*: %^{Running Length} km\n   %?")
                    ;; ("i" "Idea" entry (file+headline org-ideas-file "Misc")
                    ;;  "* TODO %^{Idea} %?\n  Entered on %U")
                    ;; ("b" "Book" plain (file org-books-file)
                    ;;  "| %^{Title} | %^{Author} | %^{Language|IT|EN} | %^{Year} | %^{Pages} | %^{Genre} | %^{Started}u | %^{Finished}u | %^{Rating|+|-|0}")
                    ;; ("f" "Film" plain (file org-films-file)
                    ;;  "| %^{Title} | %^{Language|IT|EN} | %^{Year}  | %^{Genre} | %^{Wathced}u | %^{Rating|+|-|0}")
                    ("B" "BibLaTeX" plain (file "~/documents/papers/bibliography.bib") "\n%x")
                    ("L" "Learned" entry (file "~/documents/orgs/learned.org")
                     "** %^{Learned}\n :PROPERTIES:\n :CREATED:   %U \n :END:")
                    )
                  )

            ;; GTD

            ;; From https://github.com/mwfogleman/.emacs.d/blob/master/michael.org
            (defun my-new-daily-review ()
              (interactive)
              (let ((org-capture-templates '(("d" "Review: Daily Review" entry (file+olp+datetree "~/documents/orgs/reviews.org")
                                              (file "~/documents/orgs/templates/dailyreviewtemplate.org")))))
                (progn
                  (org-capture nil "d")
                  (org-capture-finalize t)
                  (org-speed-move-safe 'outline-up-heading)
                  (org-narrow-to-subtree)
                  (fetch-calendar)
                  (org-clock-in))))

            (defun my-new-weekly-review ()
              (interactive)
              (let ((org-capture-templates '(("w" "Review: Weekly Review" entry (file+olp+datetree "~/documents/orgs/reviews.org")
                                              (file "~/documents/orgs/templates/weeklyreviewtemplate.org")))))
                (progn
                  (org-capture nil "w")
                  (org-capture-finalize t)
                  (org-speed-move-safe 'outline-up-heading)
                  (org-narrow-to-subtree)
                  (fetch-calendar)
                  (org-clock-in))))

            (bind-keys :prefix-map review-map
                       :prefix "C-c r"
                       ("d" . my-new-daily-review)
                       ("w" . my-new-weekly-review)
                       ("m" . my-new-monthly-review))

            )

     (use-package org-randomnote
       :ensure t
       :config
       (setq org-randomnote-candidates '("~/documents/orgs/learned.org"))
       (setq org-randomnote-open-behavior 'indirect-buffer)
     )

   #+END_SRC
** mu4e
   Based on https://notanumber.io/2016-10-03/better-email-with-mu4e/
   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :defer t
       :load-path "/usr/share/emacs/site-lisp/mu"
       :bind (("\C-c m" . mu4e) ("\C-x m" . mu4e-compose-new))
       :commands (mu4e-get-unread mu4e-compose-new)
       :config
       ;; This is a helper to help determine which account context I am in based
       ;; on the folder in my maildir the email (eg. ~/.mail/sbozzolator) is located in.
       (defun mu4e-message-maildir-matches (msg rx)
         (when rx
           (if (listp rx)
               ;; If rx is a list, try each one for a match
               (or (mu4e-message-maildir-matches msg (car rx))
                   (mu4e-message-maildir-matches msg (cdr rx)))
             ;; Not a list, check rx
             (string-match rx (mu4e-message-field msg :maildir)))))

       (setq mu4e-index-lazy-check t)
       (setq mail-user-agent 'mu4e-user-agent)
       (setq mu4e-mu-binary "/usr/bin/mu")
       (setq mu4e-maildir "~/.mail")
       (setq mu4e-get-mail-command "~/.offlineimap/offlineimap_parallel.sh")
       (setq mu4e-update-interval 900)
       (setq mu4e-view-show-images t)
       ;; Don't prompt for applying of marks, just apply
       (setq mu4e-headers-leave-behavior 'apply)
       ;; This enables unicode chars to be used for things like flags in the message index screens.
       (setq mu4e-use-fancy-chars t)
       ;; This enabled the thread like viewing of email similar to gmail's UI.
       (setq mu4e-headers-include-related t)
       (setq mu4e-attachment-dir  "~/downloads")
       ;; This prevents saving the email to the Sent folder since gmail will do this for us on their end.
       (setq mu4e-sent-messages-behavior 'delete)
       (setq message-kill-buffer-on-exit t)
       ;; Enable inline images.
       (setq mu4e-view-show-images t)
       ;; Use imagemagick, if available.
       (when (fboundp 'imagemagick-register-types)
         (imagemagick-register-types))

       ;; This allows me to use ivy to select mailboxes
       (setq mu4e-completing-read-function 'ivy-completing-read)
       ;; Why would I want to leave my message open after I've sent it?
       (setq message-kill-buffer-on-exit t)
       ;; Don't ask for a 'context' upon opening mu4e
       (setq mu4e-context-policy 'pick-first)
       ;; Don't ask to quit... why is this the default?
       (setq mu4e-confirm-quit nil)

       ;; Sometimes html email is just not readable in a text based client, this lets me open the
       ;; email in my browser.
       (add-to-list 'mu4e-view-actions '("View in browser" . mu4e-action-view-in-browser) t)
       (setq mu4e-view-actions (delete '("view as pdf" . mu4e-action-view-as-pdf)  mu4e-view-actions))

       ;; Spell checking ftw.
       (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)
       ;; This hook correctly modifies the \Inbox and \Starred flags on email when they are marked.
       ;; Without it refiling (archiving) and flagging (starring) email won't properly result in
       ;; the corresponding gmail action.
       (add-hook 'mu4e-mark-execute-pre-hook
                 (lambda (mark msg)
                   (cond ((member mark '(refile trash)) (mu4e-action-retag-message msg "-\\Inbox"))
                         ((equal mark 'flag) (mu4e-action-retag-message msg "\\Starred"))
                         ((equal mark 'unflag) (mu4e-action-retag-message msg "-\\Starred")))))


       ;; Bookmarks for common searches that I use.
       (setq mu4e-bookmarks '(("x:\\\\Inbox" "Inbox" ?i)
                              ("flag:unread" "Unread messages" ?u)
                              ("date:today..now" "Today's messages" ?t)
                              ("flag:flagged"       "Starred Messages"     ?f)
                              ))

       (defun mu4e-get-unread () (interactive)
              (mu4e-headers-search (mu4e-get-bookmark-query ?u)))

       (use-package smtpmail
         :defer t
         :after mu4e
         )

       (setq message-send-mail-function 'smtpmail-send-it
             starttls-use-gnutls t
             smtpmail-starttls-credentials
             '(("smtp.gmail.com" 587 nil nil))
             smtpmail-auth-credentials (expand-file-name "~/.authinfo")
             smtpmail-default-smtp-server "smtp.gmail.com"
             smtpmail-smtp-server "smtp.gmail.com"
             smtpmail-smtp-service 587
             smtpmail-debug-info t)

       ;; This sets up my two different context for my personal and work emails.
       (setq mu4e-contexts
             `(
               ;; ,(make-mu4e-context
               ;;      :name "sbozzolator"
               ;;      :enter-func (lambda () (mu4e-message "Switch to the sbozzolator context"))
               ;;      :match-func (lambda (msg)
               ;;                    (when msg
               ;;                      (mu4e-message-maildir-matches msg "^/sbozzolator")))
               ;;      :leave-func (lambda () (mu4e-clear-caches))
               ;;      :vars '((user-mail-address     . "sbozzolator@gmail.com")
               ;;              (user-full-name        . "Gabriele Bozzola")
               ;;              (mu4e-sent-folder      . "/sbozzolator/[Gmail].Sent Mail")
               ;;              (mu4e-drafts-folder    . "/sbozzolator/[Gmail].Drafts")
               ;;              (mu4e-trash-folder     . "/sbozzolator/[Gmail].Trash")
               ;;              (mu4e-refile-folder    . "/sbozzolator/[Gmail].All Mail")
               ;;              (smtpmail-smtp-user    . "sbozzlator@gmail.com")
               ;;              ))
               ,(make-mu4e-context
                 :name "bozzolagabriele"
                 :enter-func (lambda () (mu4e-message "Switch to the bozzolagabriele context"))
                 :match-func (lambda (msg)
                               (when msg
                                 (mu4e-message-maildir-matches msg "^/bozzolagabriele")))
                 :leave-func (lambda () (mu4e-clear-caches))
                 :vars '((user-mail-address     . "bozzolagabriele@gmail.com")
                         (user-full-name        . "Gabriele Bozzola")
                         (mu4e-sent-folder      . "/bozzolagabriele/[Gmail].Sent Mail")
                         (mu4e-drafts-folder    . "/bozzolagabriele/[Gmail].Drafts")
                         (mu4e-trash-folder     . "/bozzolagabriele/[Gmail].Trash")
                         (mu4e-refile-folder    . "/bozzolagabriele/[Gmail].All Mail")
                         (smtpmail-smtp-user    . "bozzolagabriele@gmail.com")
                         ))
               ,(make-mu4e-context
                 :name "sbozzolator"
                 :enter-func (lambda () (mu4e-message "Switch to the sbozzolator context"))
                 :match-func (lambda (msg)
                               (when msg
                                 (mu4e-message-maildir-matches msg "^/sbozzolator")))
                 :leave-func (lambda () (mu4e-clear-caches))
                 :vars '((user-mail-address     . "sbozzolator@gmail.com")
                         (user-full-name        . "Gabriele Bozzola")
                         (mu4e-sent-folder      . "/sbozzolator/[Gmail].Sent Mail")
                         (mu4e-drafts-folder    . "/sbozzolator/[Gmail].Drafts")
                         (mu4e-trash-folder     . "/sbozzolator/[Gmail].Trash")
                         (mu4e-refile-folder    . "/sbozzolator/[Gmail].All Mail")
                         (smtpmail-smtp-user    . "sbozzolator@gmail.com")
                         ))
               )
             )

       ;; In general I don't want to return to the mu4e main view
       (defadvice mu4e~headers-quit-buffer
           (after mu4e~headers-quit-buffer activate)
         (mu4e-alert-enable-mode-line-display)
         (kill-buffer)
         )

       ;; Let's see
       ;; (use-package mu4e-conversation
       ;;   :after mu4e
       ;;   :config
       ;;   (setq mu4e-view-func 'mu4e-conversation))

       ;; Workaround to accomplish the following
       (run-with-timer 60 600 '(lambda () (sbozzolo/start-process-shell-command "nil" nil "~/.offlineimap/send-notification")))

       ;; This is not working well on my machine...

       (setq disable-mu-update nil)
       (use-package mu4e-alert
         :after mu4e
         :init
         (setq mu4e-alert-interesting-mail-query
               (concat
                "flag:unread"    ))
         (require 'alert)
         (setq alert-default-style 'libnotify)
         (mu4e-alert-enable-mode-line-display)
         (mu4e-alert-enable-notifications)
         (mu4e-alert-set-default-style 'libnotify)
         (setq mu4e-alert-email-notification-types '(subject))
         (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
         (defun mu4e-alert--update-stats ()
           (interactive)
           (mu4e-update-mail-and-index t)
           ;; (mu4e-alert-disable-mode-line-display)
           ;; (mu4e-alert-enable-mode-line-display)
           ;; (alert "Ciao" :title "Email updated")
           (run-hooks 'mu4e-index-updated-hook)
           )
         (unless (eq disable-mu-update t)
           (run-with-timer 0 600 'mu4e-alert--update-stats)
           )
         )

       ;; Don't save drafts unless I explicitly do it
       (add-hook 'mu4e-compose-mode-hook #'(lambda () (auto-save-mode -1)))

       (defun toggle-mu-update ()
         (interactive)
         (if (eq disable-mu-update t)
             (setq disable-mu-update nil)
           (setq disable-mu-update t)
           )
         )

       )

     ;; Workaround for Gentoo (?)
     (defun mu4e-get-headers-buffer ()
       (setq  mu4e~headers-buffer (get-buffer mu4e~headers-buffer-name)))

   #+END_SRC

** Custom elisp code
   #+BEGIN_SRC emacs-lisp
     (if
	 (not (file-directory-p "~/.emacs.d/lisp"))
	 (make-directory "~/.emacs.d/lisp" t))
   #+END_SRC
** et-par
   If et-par folder doesn't exist, create it
   # #+BEGIN_SRC emacs-lisp
   (if
   (not (file-directory-p "~/.emacs.d/lisp/et-par"))
   (make-directory "~/.emacs.d/lisp/et-par"))
   #  #+END_SRC
   #  #+BEGIN_SRC emacs-lisp     :tangle lisp/et-par/et-par.el
   ;;; et-par.el --- Einstein Toolkit Parameter major mode

   ;; Copyright (C) 2001  Free Software Foundation, Inc.

   ;; Author: Gabriele Bozzola
   ;; Keywords: extensions

   ;; This file is free software; you can redistribute it and/or modify
   ;; it under the terms of the GNU General Public License as published by
   ;; the Free Software Foundation; either version 2, or (at your option)
   ;; any later version.

   ;; This file is distributed in the hope that it will be useful,
   ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
   ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   ;; GNU General Public License for more details.

   ;; You should have received a copy of the GNU General Public License
   ;; along with GNU Emacs; see the file COPYING.  If not, write to
   ;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   ;; Boston, MA 02111-1307, USA.

   ;;; Commentary:

   ;;

   ;;; Code:

   (defvar et-par-mode-syntax-table
   (let ((st (make-syntax-table)))
   (modify-syntax-entry ?# "<" st)
   (modify-syntax-entry ?\n ">" st)
   st)
   "Syntax table for `et-par-mode'.")

   (defvar et-par-font-lock-keywords
   '(("ActiveThorns \\(\\sw+\\)" (1 font-lock-function-name-face)))
   "Keyword highlighting specification for `et-par-mode'.")

   ;;;###autoload
   (define-derived-mode et-par-mode fundamental-mode "ET-par"
   "A major mode for editing Et-Par files."
   :syntax-table et-par-mode-syntax-table
   (setq-local comment-start "# ")
   (setq-local comment-start-skip "#+\\s-*")
   (setq-local font-lock-defaults
   '(et-par-font-lock-keywords))
   )

   (provide 'et-par)
   ;;; et-par.el ends here
   #   #+END_SRC

   Load tangled file
   #+BEGIN_SRC emacs-lisp
     ;; (if (file-exists-p (substitute-in-file-name "$HOME/.emacs.d/lisp/et-par/et-par.el"))
     ;;   (load "~/.emacs.d/lisp/et-par/et-par.el")
     ;;   (require 'et-par)
     ;;   (add-to-list 'auto-mode-alist '("\\.par\\'" . et-par-mode))
     ;;   )
   #+END_SRC
** Highlight symbol
   Highlight occurences of a given word. Handy when programming.
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-symbol
   :commands (highlight-symbol)
   :bind (("\C-c h " . highlight-symbol))
  )
   #+END_SRC
** Easy-hugo
   #+BEGIN_SRC emacs-lisp
     (use-package easy-hugo
       :defer t
       :commands (easy-hugo)
       :config
       (setq easy-hugo-basedir "/home/sbozzolo/documents/my_website/")
       (setq easy-hugo-url "https://sbozzolo.github.io")
       (setq easy-hugo-postdir "content/publication")
       (setq easy-hugo-root "/home/sbozzolo/documents/my_website")
       (setq easy-hugo-previewtime 300)
       (setq easy-hugo-default-ext ".md")
       )
   #+END_SRC
** Git timemachine
   #+BEGIN_SRC emacs-lisp
        (use-package git-timemachine
        :defer t
        :commands (git-timemachine)
        )
   #+END_SRC
** bibslurp
   With this package I can retrive bib files from NASA ADSABS
   #+BEGIN_SRC emacs-lisp
     (use-package bibslurp
       :defer t
       ;:load-path "~/.emacs.d/lisp/bibslurp"
       :bind (("C-c b s" . bibslurp-query-ads)
              ("C-c b a" . sbozzolo/arxiv-get-pdf-from-bib-entry)
              :map bibslurp-mode-map
              ("x" . sbozzolo/bibslurp-visit-arxiv)
              )
       :config
       (setq ads-auth-token sbozzolo-ads-auth-token)
       (defun sbozzolo/bibslurp-visit-arxiv ()
         "Download pdf and display it in bibslurp"
         (interactive)
         (let* ((link-number (get-text-property (point) 'number))
                (abs-url (bibslurp/follow-link link-number))
                )
           (when abs-url
             (with-temp-buffer
               (url-insert-file-contents (bibslurp/follow-link link-number))
               (let ((meta (bibslurp/format-abs-meta))
                     (abs (bibslurp/format-abs-text))
                     (arxiv-number (progn
                                     (goto-char (point-min))
                                     (re-search-forward
                                      "<meta\\s-+name=\"citation_arxiv_id\"\\s-+content=\"\\(.*?\\)\""
                                      nil)
                                     (match-string 1)))
                     )
                 (sbozzolo/arxiv-open-pdf arxiv-number)
                 )
               )
             )
           )
         )
       (defadvice bibslurp-slurp-bibtex
           (after bibslurp-slurp-bibtex activate)
         ;; Temporary change org-templates
         (let* ((org-capture-templates '(("b" "BibLaTeX for bibslurp" plain (file "~/documents/papers/bibliography.bib") "\n%c"
                                          :immediate-finish t))))
           (org-capture nil "b")
           (message "Copied to the bibliography file!")
           )
         (let* ((link-number (get-text-property (point) 'number))
                (abs-url (bibslurp/follow-link link-number))
                )
           (when abs-url
             (with-temp-buffer
               (url-insert-file-contents (bibslurp/follow-link link-number))
               (let ((meta (bibslurp/format-abs-meta))
                     (abs (bibslurp/format-abs-text))
                     (arxiv-number (progn
                                     (goto-char (point-min))
                                     (re-search-forward
                                      "<meta\\s-+name=\"citation_arxiv_id\"\\s-+content=\"\\(.*?\\)\""
                                      nil)
                                     (match-string 1)))
                     )
                 (when (and meta abs)
                   (let* ((title (car (split-string meta "\n")))
                          (authors (cadr (split-string meta "\n")))
                          (journal (caddr (split-string meta "\n")))
                          (pdf-file-path (concat arxiv-papers-folder "/" arxiv-number ".pdf"))
                          (paper-metadata (concat "* [[file:" pdf-file-path "][" title  "]]\n  " authors "\n  " journal "\n  ArXiv number: " arxiv-number "\n** Abstract" abs))
                          (org-capture-templates `(("i" "index for bibslurp" plain (file arxiv-papers-index) ,paper-metadata :immediate-finish t)))
                          )
                     (org-capture nil "i")
                     (sbozzolo/arxiv-download-pdf arxiv-number)
                     (message "Metadata added to index")
                     )
                   )
                 )
               )
             )
           )
         )

       (setq arxiv-papers-folder "~/documents/papers/arxiv")
       (setq arxiv-papers-index "~/documents/papers/arxiv/papers_arxiv.org")

       (defun org-ref-pdf-p (filename)
         "Check if FILENAME is PDF file.

     From the PDF specification 1.7:

         The first line of a PDF file shall be a header consisting of
         the 5 characters %PDF- followed by a version number of the
         form 1.N, where N is a digit between 0 and 7."
         (let ((header (with-temp-buffer
                         (set-buffer-multibyte nil)
                         (insert-file-contents-literally filename nil 0 5)
                         (buffer-string))))
           (string-equal (encode-coding-string header 'utf-8) "%PDF-")))

       (defun sbozzolo/arxiv-get-pdf-from-bib-entry ()
         "Get the pdf of the current bib entry (from arXiv). If what is at point
        starts with a number, get the pdf with that arxiv number."
         (interactive)
         ;; Wrap the predicate around condition case so that if it fails it goes to
         ;; the false branch of the if
         (if (condition-case nil
                 (string-match-p "[0-9]" (substring (thing-at-point 'word) 0 1))
               (error nil)
               )
             (sbozzolo/arxiv-open-pdf (concat (thing-at-point 'word) "." (progn (forward-word 2) (thing-at-point 'word))))
           (if (eq major-mode 'latex-mode)
               (progn
                 (reftex-view-crossref)
                 (dolist (buf (buffer-list))
                   (with-current-buffer buf
                     (when (eq major-mode 'bibtex-mode)
                       (switch-to-buffer buf)
                       (delete-other-windows)
                       (narrow-to-defun)
                       (if (condition-case nil
                               (search-forward "eprint")
                             (error nil)
                             )
                           (sbozzolo/arxiv-open-pdf (substring (format "%s" (cdr (split-string (thing-at-point 'sentence) "="))) 3 -3))
                           (message "The reference does not have an arxiv number!")
                           )
                       (widen)
                       (kill-buffer buf)
                       )))
                 )
             (message "This function cannot recognize papers outside tex files unless the point is on an arxiv number")
             )
           )
         )

       (defun sbozzolo/arxiv-download-pdf (arxiv-number)
         "Retrieve a pdf for ARXIV-NUMBER and save it in the arxiv-papers-folder."
         (let* ((pdf (concat arxiv-papers-folder "/" arxiv-number ".pdf") )
                (pdf-url
                 (unless (file-exists-p pdf)
                   (with-current-buffer
                       (url-retrieve-synchronously
                        (concat
                         "http://arxiv.org/abs/" arxiv-number))
                     ;; <meta name="citation_pdf_url" content="http://arxiv.org/pdf/0801.1144" />
                     (goto-char (point-min))
                     (search-forward-regexp
                      "name=\\\"citation_pdf_url\\\" content=\\\"\\(.*\\)\\\"")
                     (match-string 1))
                   )))
           (progn                            ; Otherwhise, download it and open it
             (url-copy-file pdf-url pdf)
             ;; now check if we got a pdf
             (unless (org-ref-pdf-p pdf)
               (delete-file pdf)
               (message "Error downloading arxiv pdf %s" pdf-url))
             )
           )
         )

       ;; Based on org-ref arxiv-get-pdf
       (defun sbozzolo/arxiv-open-pdf (arxiv-number)
         "Open PDF of paper with ARXIV-NUMBER, if it does not exsist, download it."
         (let ((pdf (concat arxiv-papers-folder "/" arxiv-number ".pdf")))
           (unless (file-exists-p pdf)
             (sbozzolo/arxiv-download-pdf arxiv-number)
             )
           (org-open-file pdf)
           )
         )
       )
   #+END_SRC

* EXWM
  #+BEGIN_SRC emacs-lisp
    (use-package xelb
      ;:load-path  "~/.emacs.d/lisp/xelb/"
      )

    (use-package exwm
      ;:load-path  "~/.emacs.d/lisp/exwm/"
      :config
      ;;Send C-q to escape keys
      (push ?\C-q exwm-input-prefix-keys)
      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

      ;; ediff workaround
      (setq ediff-window-setup-function 'ediff-setup-windows-plain)

      ;; Movement keys
    (setq exwm-input-simulation-keys
          '(
            ;; movement
            ([?\C-b] . [left])
            ([?\M-b] . [C-left])
            ([?\C-f] . [right])
            ([?\M-f] . [C-right])
            ([?\C-p] . [up])
            ([?\C-n] . [down])
            ([?\C-a] . [home])
            ([?\C-e] . [end])
            ([?\M-v] . [prior])
            ([?\C-v] . [next])
            ([?\C-d] . [delete])
            ([?\C-k] . [S-end delete])
            ([?\C-m] . [return])
            ;; cut/paste.
            ([?\C-w] . [?\C-x])
            ([?\M-w] . [?\C-c])
            ([?\C-y] . [?\C-v])
            ;; search
            ([?\C-s] . [?\C-f])))


      ;; (dolist (k '(XF86AudioLowerVolume
      ;;              XF86AudioRaiseVolume
      ;;              XF86PowerOff
      ;;              XF86AudioMute
      ;;              XF86AudioPlay
      ;;              XF86AudioStop
      ;;              XF86AudioPrev
      ;;              XF86AudioNext
      ;;              XF86ScreenSaver
      ;;              XF68Back
      ;;              XF86Forward
      ;;              Scroll_Lock
      ;;              print))
      ;;   (cl-pushnew k exwm-input-prefix-keys))

      ;; Hide modeline of floating X windows
      (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
      ;; Hide minibuffer when not used
      (setq exwm-workspace-minibuffer-position 'bottom)

      ;; Allow to read from minibuffer while in minibuffer.
      (setq enable-recursive-minibuffers t)

      ;; Rename buffer with title
      (defun exwm-rename-buffer ()
        (interactive)
        (exwm-workspace-rename-buffer
                                            ; Get first word of the name
         (concat "(" (car (split-string exwm-class-name "[ \f\t\n\r\v-]+")) ") "
                 (if (<= (length exwm-title) 30) exwm-title
                   (concat (substring exwm-title 0 29) "...")))))

      ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
      (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
      (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)

      ;; X apps are usable across the workspaces
      (setq exwm-workspace-show-all-buffers t
            exwm-layout-show-all-buffers    t)

      ;; Bindings
      ;; I want to make sure that the programs are run from the localhost
      (defun sbozzolo/start-process-shell-command (name buffer command)
        (interactive)
        (let ((default-directory "~/"))
          (start-process-shell-command name buffer command)
          )
        )

      (defun sbozzolo/shell-command-to-string (command)
        (interactive)
        (let ((default-directory "~/"))
          (shell-command-to-string command)
          )
        )

      ;; Set windmove and winnder in X apps
      (exwm-input-set-key (kbd "s-k") 'windmove-up)
      (exwm-input-set-key (kbd "s-h") 'windmove-left)
      (exwm-input-set-key (kbd "s-j") 'windmove-down)
      (exwm-input-set-key (kbd "s-l") 'windmove-right)

      (exwm-input-set-key (kbd "C-<prior>")     'winner-undo)
      (exwm-input-set-key (kbd "C-<next>")      'winner-redo)
      (exwm-input-set-key (kbd "C-s-j")         'winner-undo)
      (exwm-input-set-key (kbd "C-s-k")         'winner-redo)
      (exwm-input-set-key (kbd "<XF86Back>")    'winner-undo)
      (exwm-input-set-key (kbd "<XF86Forward>") 'winner-redo)

      ;; Launch multi-term
      ;; (exwm-input-set-key (kbd "s-t") '(lambda () (interactive)
      ;;                                    (if (string-match-p (regexp-quote "@") default-directory)
      ;;                                        (let ((default-directory "~/"))
      ;;                                          (multi-term)
      ;;                                          )
      ;;                                          (multi-term)
      ;;                                          )
      ;;                                    )
      ;;                     )
      (exwm-input-set-key (kbd "s-t") 'vterm)
      (exwm-input-set-key (kbd "s-v") 'vterm-toggle-cd)

      ;; Launch multi-term
      (exwm-input-set-key (kbd "s-C-t") '(lambda () (interactive)
                                           (sbozzolo/start-process-shell-command "xterm" nil "xterm")
                                           )
                          )

      ;; Launch Mathematica
      (exwm-input-set-key (kbd "s-m") '(lambda () (interactive)
                                         (sbozzolo/start-process-shell-command "mathematica" nil "mathematica")
                                         )
                          )

      ;; + We always need a way to go back to line-mode from char-mode
      (exwm-input-set-key (kbd "s-r") 'exwm-reset)

      ;; + Bind a key to switch workspace interactively
      (exwm-input-set-key (kbd "s-w") 'exwm-workspace-switch)

      (exwm-input-set-key (kbd "s-c") '(lambda () (interactive)
                                         (sbozzolo/start-process-shell-command "chromium"
                                                                               nil "chromium --enable-native-gpu-memory-buffers --process-per-site --app=https://duck.com")
                                         ))

      (exwm-input-set-key (kbd "s-f") '(lambda () (interactive)
                                         (sbozzolo/start-process-shell-command "firefox" nil "firefox")
                                         ))

      ;; Redshift off
      ;(exwm-input-set-key (kbd "s-x")
      ;                    (lambda () (interactive) (start-process "" nil "redshift" "-x" )))
      ;; Redshift on
      ;(exwm-input-set-key (kbd "s-z")
      ;                    (lambda () (interactive) (start-process "" nil "redshift" "-c ~/.redshiftrc")))

      ;; + Bind "s-0" to "s-8" to switch to the corresponding workspace.
      (dotimes (i 9)
        (exwm-input-set-key (kbd (format "s-%d" i))
                            `(lambda ()
                               (interactive)
                               (exwm-workspace-switch-create ,i))))
      ;; + Application launcher ('M-&' also works if the output buffer does not
      ;;   bother you). Note that there is no need for processes to be created by
      ;;   Emacs.
      (exwm-input-set-key (kbd "s-&")
                          (lambda (command)
                            (interactive (list (read-shell-command "$ ")))
                            (start-process-shell-command command nil command)))

      ;; + 'slock' is a simple X display locker provided by suckless tools.
      (exwm-input-set-key (kbd "s-<f2>")
                          (lambda () (interactive) (start-process "" nil "slock")))

      ;; Take a screenshot
      (exwm-input-set-key (kbd "<print>")
                          '(lambda () (interactive)
                             (progn
                               (sbozzolo/shell-command-to-string "import -window root ~/screenshots/$(date +%Y-%m-%d:%H:%M:%S).png")
                               (alert "Screenshot taken! Saved in ~/screenshots" :title "Screenshot")
                               )
                             )
                          )

      ;; Take a screenshot of part of the screen
      (exwm-input-set-key (kbd "<s-print>")
                          '(lambda () (interactive)
                             (progn
                               (sbozzolo/shell-command-to-string "import ~/screenshots/$(date +%Y-%m-%d:%H:%M:%S).png")
                               (alert "Screenshot taken! Saved in ~/screenshots" :title "Screenshot")
                               )
                             )
                          )

      ;; Shutdown computer from inside emacs
      (defun shutdown ()
        "Kills gracefully emacs and the whole system appending
                      shutdown to kill-emacs-hook"
        (interactive)
        (if (y-or-n-p "Shutdown? ")
            (progn
              (add-hook 'kill-emacs-hook (lambda () (shell-command "systemctl poweroff")) t)
              (if (internet-up-p)
                  (message (shell-command-to-string "commitorgs")) )
              (unless (eq (get-process "mu4e-update") nil)
                (delete-process "mu4e-update"))
              (save-buffers-kill-terminal)
              )
          (progn
            (message "Staying alive")
            )
          )
        )

      (exwm-input-set-key (kbd "s-x s-c") #'shutdown)
      (exwm-input-set-key (kbd "<XF86PowerOff>") #'shutdown)

      ;; EXWM RANDR (TO BE FIXED...)

      (require 'exwm-randr)

      ;; (add-hook 'exwm-randr-screen-change-hook
      ;;           (lambda ()
      ;;             (start-process-shell-command
      ;;              "xrandr" nil "xrandr --output VGA-1 --same-as LVDS-1 --auto")))
           (setq exwm-randr-workspace-output-plist '(0 "eDP-1" 1 "DP-2-2" 2 "DP-2-3"))

      (setq exwm-randr-clone nil)

        ;; Implement auto switch with the following
      ;; (defun exwm-change-screen-hook ()
      ;;   (let ((xrandr-output-regexp "\n\\([^ ]+\\) connected ")
      ;;         default-output)
      ;;     (with-temp-buffer
      ;;       (call-process "xrandr" nil t nil)
      ;;       (goto-char (point-min))
      ;;       (re-search-forward xrandr-output-regexp nil 'noerror)
      ;;       (setq default-output (match-string 1))
      ;;       (forward-line)
      ;;       (if (not (re-search-forward xrandr-output-regexp nil 'noerror))
      ;;           (call-process "xrandr" nil nil nil "--output" default-output "--auto")
      ;;         (call-process
      ;;          "xrandr" nil nil nil
      ;;          "--output" (match-string 1) "--primary" "--auto"
      ;;          "--output" default-output "--off")
      ;;         (setq exwm-randr-workspace-output-plist (list 0 (match-string 1)))))))

      ;; (add-hook 'exwm-randr-screen-change-hook 'exwm-change-screen-hook)


                                            ;        (setq exwm-randr-workspace-output-plist '(0 "LVDS-1"))
      ;(setq exwm-randr-workspace-output-plist '(0 "VGA-1"))
                                            ;(setq exwm-randr-workspace-output-plist '(0 "LVDS-1"))
                                            ;(setq exwm-randr-workspace-output-plist '(0 "VGA-1"))



      (defun toggle-exwm-randr ()
        (interactive)
        (if (eq exwm-randr-clone t)
            (progn
              (remove-hook 'exwm-randr-screen-change-hook
                           (lambda ()
                             (start-process-shell-command
                              "xrandr" nil "xrandr --output VGA-1 --same-as LVDS-1 --auto")))
              (add-hook 'exwm-randr-screen-change-hook
                        (lambda ()
                          (start-process-shell-command
                           "xrandr" nil "xrandr --output VGA-1 --right-of LVDS-1 --auto")))
              (setq exwm-randr-clone nil)
              (alert "Output on the right" :title "Randr")
              (redraw-display)
              )
          (progn
            (remove-hook 'exwm-randr-screen-change-hook
                         (lambda ()
                           (start-process-shell-command
                            "xrandr" nil "xrandr --output VGA-1 --right-of LVDS-1 --auto")))
            (add-hook 'exwm-randr-screen-change-hook
                      (lambda ()
                        (start-process-shell-command
                         "xrandr" nil "xrandr --output VGA-1 --same-as LVDS-1 --auto")))
            (setq exwm-randr-clone t)
            (alert "Output cloning, remove VGA cable, wait 1 s, insert VGA cable" :title "Randr")
            (redraw-display)
            )
          )
        )

      (exwm-randr-enable)


      ;; XF86 keys

      ;; Toggle clone and extend
      (exwm-input-set-key (kbd "<XF86Display>") #'toggle-exwm-randr)

      ;; Calculator
      (exwm-input-set-key (kbd "<XF86Calculator>") #'calc)


      ;; Print volume and brightness
      ;; Sleep is put so that the command is executed after the change
      (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                          '(lambda () (interactive)
                             (alert (concat "Brightness: "
                                            (substring (sbozzolo/shell-command-to-string "sleep 0.05; xbacklight -get") 0 -1)
                                            " %"
                                            )
                                    :title "Brightness")))

      (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                          '(lambda () (interactive)
                             (alert (concat "Brightness: "
                                            (substring (sbozzolo/shell-command-to-string "sleep 0.05; xbacklight -get") 0 -1)
                                            " %"
                                            )
                                    :title "Brightness")))


      (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>")
                          '(lambda () (interactive)
                             (alert (concat "Volume: "
                                            (substring (sbozzolo/shell-command-to-string "sleep 0.05; amixer get Master | grep '%'| cut -d'[' -f2 | cut -d '%' -f1") 0 -1)
                                            " %"
                                            )
                                    :title "Volume")))

      (exwm-input-set-key (kbd "<XF86AudioLowerVolume>")
                          '(lambda () (interactive)
                             (alert (concat "Volume: "
                                            (substring (sbozzolo/shell-command-to-string "sleep 0.05; amixer get Master | grep '%'| cut -d'[' -f2 | cut -d '%' -f1") 0 -1)
                                            " %"
                                            )
                                    :title "Volume")))

      (exwm-input-set-key (kbd "<XF86AudioMute>")
                          '(lambda () (interactive)
                             (alert (concat "Master is "
                                            (substring (sbozzolo/shell-command-to-string "sleep 0.05; amixer get Master | grep '%'| cut -d'[' -f4 | cut -d']' -f1") 0 -1)
                                            )
                                    :title "Audio")))

      (exwm-input-set-key (kbd "<XF86AudioMicMute>")
                          '(lambda () (interactive)
                             (alert (concat "Microphone is "
                                            (substring (sbozzolo/shell-command-to-string "sleep 0.05; amixer get Capture | grep '%'| cut -d'[' -f4 | cut -d']' -f1 | head -n 1") 0 -1)
                                            )
                                    :title "Microphone")))

      ;;Function-keys-binding
      (exwm-input-set-key (kbd "<f1>") #'delete-other-windows)
      (exwm-input-set-key (kbd "<f2>") #'kill-this-buffer)
      (exwm-input-set-key (kbd "<f3>") #'split-window-right)
      (exwm-input-set-key (kbd "<f4>") '(lambda () (interactive) (find-file org-todo-file)))
      ;; (exwm-input-set-key (kbd "<f5>") #'revert-buffer)
      ;; I don't use exwm-input so I can use F5 in X apps
      (global-set-key (kbd "<f5>") 'revert-buffer)
      (exwm-input-set-key (kbd "<f6>") #'mu4e-get-unread)
      (exwm-input-set-key (kbd "<f7>") '(lambda () (interactive) (find-file org-projects-file)))
      (exwm-input-set-key (kbd "<f8>") '(lambda () (interactive) (find-file org-scheduled-file)))
      ;; (exwm-input-set-key (kbd "<f8>") #')
      ;; (exwm-input-set-key (kbd "<f9>") #')
      ;; (exwm-input-set-key (kbd "<f10>") #')
      (exwm-input-set-key (kbd "<f11>") #'toggle-menu-bar-mode-from-frame)
      (exwm-input-set-key (kbd "<f12>") #'org-capture)

      ;; Enable EXWM!
      (exwm-enable)

      )
  #+END_SRC

* Garbage Collector II
  2 M is ok after the init
  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold 20000000)
  #+END_SRC
* Lab
  #+BEGIN_SRC emacs-lisp
    ;; bibslurp
      ;; (request
      ;;  "https://api.adsabs.harvard.edu/v1/search/query?q=2019arXiv190301036B"
      ;;  :params '( ("fl" . "title"))
      ;;  :parser 'json-read
      ;;  :headers `(("Authorization" . ,(concat "Bearer " "N9jMZ78D6ocqgU5OG25j7NXOcWDvBXvnMlxzLGg9")))
      ;;  :success (cl-function
      ;;            (lambda (&key data &allow-other-keys)
      ;;              (message "I sent: %S" (data)))))

      ;; (custom-set-variables '(request-log-level 'blather)
      ;;                                    '(request-message-level 'blather))
  #+END_SRC

#+END_SRC

  #+BEGIN_SRC emacs-lisp
      (exwm-input-set-key (kbd "<XF86Tools>")
                          #'(lambda ()
                          (interactive)
                               (progn
                                      (delete-other-windows)
                                      (find-file "/home/sbozzolo/.emacs.d/settings.org")
                                      )
                              )
                          )

      (exwm-input-set-key (kbd "<XF86Search>")
                          #'(lambda ()
                          (interactive)
                               (progn
                                      (delete-other-windows)
                                      (find-file "/home/sbozzolo/documents/papers/arxiv/papers_arxiv.org")
                                      )
                              )
                          )

    ;;                       (setq debug-on-error nil)
    ;; ;; (setq debug-on-quit t)
    ;; (setq edebug-all-forms nil)
    ;; (setq exwm-debug-on nil)
  #+END_SRC
** All-the-icons
   #+BEGIN_SRC emacs-lisp
     ;; (use-package all-the-icons :defer 0.5)
     ;; (use-package all-the-icons-ivy
     ;;   :after (all-the-icons ivy)
     ;;     :custom (all-the-icons-ivy-file-commands '(counsel-dired-jump
     ;;                                                counsel-find-file
     ;;                                                counsel-file-jump
     ;;                                                counsel-find-library
     ;;                                                counsel-git
     ;;                                                counsel-projectile-find-dir
     ;;                                                counsel-projectile-find-file
     ;;                                                counsel-recentf))
     ;;     :config (all-the-icons-ivy-setup))
   #+END_SRC

** Misc Functions I don't use too much
   #+BEGIN_SRC emacs-lisp
     ;; Swap buffer in window
     (defun swap-buffers-in-windows ()
       "Put the buffer from the selected window in next window, and vice versa"
       (interactive)
       (let* ((this (selected-window))
              (other (next-window))
              (this-buffer (window-buffer this))
              (other-buffer (window-buffer other)))
         (set-window-buffer other this-buffer)
         (set-window-buffer this other-buffer)
         )
       )

     ;; ;; Switch configuration from horizontal to vertical and vice versa
     ;; (defun toggle-window-split ()
     ;;   (interactive)
     ;;   (if (= (count-windows) 2)
     ;;       (let* ((this-win-buffer (window-buffer))
     ;;              (next-win-buffer (window-buffer (next-window)))
     ;;              (this-win-edges (window-edges (selected-window)))
     ;;              (next-win-edges (window-edges (next-window)))
     ;;              (this-win-2nd (not (and (<= (car this-win-edges)
     ;;                                          (car next-win-edges))
     ;;                                      (<= (cadr this-win-edges)
     ;;                                          (cadr next-win-edges)))))
     ;;              (splitter
     ;;               (if (= (car this-win-edges)
     ;;                      (car (window-edges (next-window))))
     ;;                   'split-window-horizontally
     ;;                 'split-window-vertically)))
     ;;         (delete-other-windows)
     ;;         (let ((first-win (selected-window)))
     ;;           (funcall splitter)
     ;;           (if this-win-2nd (other-window 1))
     ;;           (set-window-buffer (selected-window) this-win-buffer)
     ;;           (set-window-buffer (next-window) next-win-buffer)
     ;;           (select-window first-win)
     ;;           (if this-win-2nd (other-window 1))))))
   #+END_SRC
** vterm
   #+BEGIN_SRC emacs-lisp
          (use-package vterm
            :load-path  "~/.emacs.d/lisp/emacs-libvterm/"
            :defer t
            :commands (vterm)
            :bind     (("C-c C-k" . vterm-copy-mode))
            :config
            (add-hook 'vterm-exit-functions #'(lambda (buf)
                                                (when buf (kill-buffer buf))))
            ;; Remove binding of <f#>, and move it to S-<f#>
            (cl-loop for number from 1 to 12 do
                     (progn
                       (define-key vterm-mode-map (kbd (format "<f%i>" number)) nil)
                       )
                     )

            (defun starts-with-p (line prompt)
              "Check if LINE starts with PROMPT"
              (string= (substring line 0 (length prompt)) prompt)
              )

            (defun is-a-prompt-p (line)
              "Check if the LINE is the input line of some interactive process."
              (or
               (starts-with-p line "$")
               (starts-with-p line "gnuplot>")
               (starts-with-p line ">>>")
               (starts-with-p line "In ")
               )
              )

            (defun send-command-input (command &optional args)
              "Check if the point is in the input line, if it is, send the
               command with vterm. This works only if the first characters
               of the line are in the database of is-a-prompt-p."
              (if (is-a-prompt-p (thing-at-point 'line))
                  (vterm--self-insert)            ; Prompt line
                (funcall command args)
                )
              )

            (defun vterm-yank-primary ()
              "Implementation of `mouse-yank-primary' (paste) in vterm."
              (interactive)
              (let ((inhibit-read-only t)
                    (primary (gui-get-primary-selection)))
                (cl-letf (((symbol-function 'insert-for-yank)
                           #'(lambda(str) (vterm-send-string str t))))
                    (insert-for-yank primary))))


            (define-key vterm-mode-map (kbd "C-f") '(lambda () (interactive) (send-command-input 'forward-char)))
            (define-key vterm-mode-map (kbd "C-b") '(lambda () (interactive) (send-command-input 'backward-char)))
            (define-key vterm-mode-map (kbd "C-n") nil)
            (define-key vterm-mode-map (kbd "C-p") nil)
            (define-key vterm-mode-map (kbd "C-y") 'vterm-yank)
            (define-key vterm-mode-map (kbd "<mouse-2>") 'vterm-yank-primary)
            (define-key vterm-mode-map (kbd "C-s") '(lambda () (interactive) (send-command-input 'counsel-grep-or-swiper)))
            (define-key vterm-mode-map (kbd "C-r") '(lambda () (interactive) (send-command-input 'counsel-grep-or-swiper)))
            (define-key vterm-mode-map (kbd "M-f") '(lambda () (interactive) (send-command-input 'forward-word)))
            (define-key vterm-mode-map (kbd "M-b") '(lambda () (interactive) (send-command-input 'backward-word)))
            (define-key vterm-mode-map (kbd "C-e") '(lambda () (interactive) (send-command-input 'move-end-of-line)))
            (define-key vterm-mode-map (kbd "C-a") '(lambda () (interactive) (send-command-input 'move-beginning-of-line)))
            (define-key vterm-mode-map (kbd "M-w") '(lambda () (interactive) (send-command-input
                                                                         '(lambda (interactive)
                                                                            (kill-ring-save (point) (mark t))
                                                                            ))))

            (define-key vterm-mode-map (kbd "C-SPC") '(lambda () (interactive) (send-command-input 'set-mark-command)))

            ;; Kill-word backwords
            (define-key vterm-mode-map (kbd "<C-backspace>") '(lambda () (interactive) (vterm-send-key (kbd "C-w"))))
            (define-key vterm-mode-map (kbd "C-m") '(lambda () (interactive) (vterm-send-key (kbd "RET"))))

            ;; I cannot get the loop to work...
            (define-key vterm-mode-map (kbd "C-<f0>") '(lambda () (interactive) (vterm-send-key "<f0>")))
            (define-key vterm-mode-map (kbd "C-<f1>") '(lambda () (interactive) (vterm-send-key "<f1>")))
            (define-key vterm-mode-map (kbd "C-<f2>") '(lambda () (interactive) (vterm-send-key "<f2>")))
            (define-key vterm-mode-map (kbd "C-<f3>") '(lambda () (interactive) (vterm-send-key "<f3>")))
            (define-key vterm-mode-map (kbd "C-<f4>") '(lambda () (interactive) (vterm-send-key "<f4>")))
            (define-key vterm-mode-map (kbd "C-<f5>") '(lambda () (interactive) (vterm-send-key "<f5>")))
            (define-key vterm-mode-map (kbd "C-<f6>") '(lambda () (interactive) (vterm-send-key "<f6>")))
            (define-key vterm-mode-map (kbd "C-<f7>") '(lambda () (interactive) (vterm-send-key "<f7>")))
            (define-key vterm-mode-map (kbd "C-<f8>") '(lambda () (interactive) (vterm-send-key "<f8>")))
            (define-key vterm-mode-map (kbd "C-<f9>") '(lambda () (interactive) (vterm-send-key "<f9>")))
            (define-key vterm-mode-map (kbd "C-<f10>") '(lambda () (interactive) (vterm-send-key "<f10>")))
            (define-key vterm-mode-map (kbd "C-<f11>") '(lambda () (interactive) (vterm-send-key "<f11>")))
            (define-key vterm-mode-map (kbd "C-<f12>") '(lambda () (interactive) (vterm-send-key "<f12>")))

            ;; (defvar vterm-user "")
            ;; (make-variable-buffer-local 'vterm-user)
            ;; (defvar vterm-host "")
            ;; (make-variable-buffer-local 'vterm-host)
            ;; (defvar vterm-pwd "")
            ;; (make-variable-buffer-local 'vterm-pwd)
            ;; (defvar vterm-cmd "")
            ;; (make-variable-buffer-local 'vterm-cmd)

            ;; (defun vterm-set-title-hook (title) ;title = user@host@lastcmd:path  or user@host:path
            ;;   (let* ((tokens (split-string title ":" ))
            ;;          dir)
            ;;     (when (equal 2 (length tokens))
            ;;       (setq vterm-pwd (string-trim-left (nth 1 tokens)))
            ;;       (setq tokens (split-string (nth 0 tokens) "@" ))
            ;;       (when (>  (length tokens) 1)
            ;;         (setq vterm-user (nth 0 tokens))
            ;;         (setq vterm-host (nth 1 tokens))
            ;;         (when (and (nth 2 tokens)
            ;;                    (not (string-empty-p (or (nth 2 tokens) ""))))
            ;;           (setq vterm-cmd (nth 2 tokens))))
            ;;       (setq dir
            ;;             (file-name-as-directory
            ;;              (if (and (string= vterm-host (system-name))
            ;;                       (string= vterm-user (user-real-login-name)))
            ;;                  (expand-file-name vterm-pwd)
            ;;                (concat "/-:" vterm-user "@" vterm-host ":"
            ;;                        vterm-pwd))))
            ;;       (when (ignore-errors (file-directory-p dir))
            ;;         (cd-absolute dir))
            ;;       (message title)
            ;;       ;; (message "pwd=%s,user=%s,host=%s,cmd=%s d=%s"
            ;;       ;;          vterm-pwd vterm-user vterm-host vterm-cmd dir)
            ;;       (rename-buffer (format "term %s %s@%s:%s" vterm-cmd vterm-user vterm-host vterm-pwd ) t)

     ;       (add-hook 'vterm-set-title-functions 'vterm-set-title-hook)
            )

          (use-package vterm-toggle
            :load-path  "~/.emacs.d/lisp/vterm-toggle/"
            :defer t
            :commands (vterm-toggle-cd)
            )

   #+END_SRC
** telega
   #+BEGIN_SRC emacs-lisp
     (use-package telega
       :load-path  "~/.emacs.d/lisp/telega.el/"
       :bind ("s-q" . telega)
       :config
       (use-package visual-fill-column)
       )
   #+END_SRC
** Yasnippet
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :defer t
       :hook
      ((prog-mode . yas-minor-mode)
      (LaTeX-mode . yas-minor-mode))
       :config
       (use-package yasnippet-snippets
       :config
       (yas-reload-all))
       )
   #+END_SRC
** ielm
   #+BEGIN_SRC emacs-lisp
    (use-package ielm
      )
   #+END_SRC
** Start emacs server
  If emacs-server it is not running, start it.
  I actually never use it, but it seems to be needed for pdf-tools
  #+BEGIN_SRC emacs-lisp
    (use-package server
       :defer 180
       :config (unless (server-running-p) (server-start))
    )
  #+END_SRC
** which-key
   Show help when typing a command, which is pretty handy in some cases.
   I don't use it very often...
  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :diminish which-key-mode
      :config
      (which-key-mode)
      (which-key-setup-side-window-right)
      )
  #+END_SRC

** exwm-edit
  #+BEGIN_SRC emacs-lisp
    (use-package exwm-edit)
  #+END_SRC
* Old unused code
** GNUs
   #+BEGIN_SRC emacs-lisp
    ;; ;;;; RECEIVE
    ;; (setq gnus-secondary-select-methods
    ;;       '((nnimap "gmail"
    ;;                 (nnimap-address "imap.gmail.com")
    ;;                 (nnimap-server-port 993)
    ;;                 (nnimap-authenticator login)
    ;;                 (nnimap-expunge-on-close 'never)
    ;;                 (nnimap-stream ssl))))

    ;; (setq imap-ssl-program "openssl s_client -quiet -ssl3 -connect %s:%p")
    ;; (setq imap-log t)

    ;; ;;;; SEND
    ;; (setq message-send-mail-function 'smtpmail-send-it
    ;;       smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
    ;;       smtpmail-auth-credentials '(("smtp.gmail.com" 587 "sbozzolator@gmail.com" nil))
    ;;       smtpmail-default-smtp-server "smtp.gmail.com"
    ;;       smtpmail-smtp-server "smtp.gmail.com"
    ;;       smtpmail-smtp-service 587
    ;;       mail-host-address "sbozzolator@gmail.com")
   #+END_SRC
** Guru-mode
   I don't need anymore a guru mode
   #+BEGIN_SRC emacs-lisp
     (use-package guru-mode
       :diminish guru-mode
       :init
       (guru-global-mode t)
       )
   #+END_SRC
** Synonyms
   The idea behind this package is cool, but at the end of the day it is not implemented
   well. It's difficult to get an actual synonym.
   #+BEGIN_SRC emacs-lisp
    ;; (use-package synonyms
    ;;   :config
    ;;   (if (file-exists-p (substitute-in-file-name "$HOME/.emacs.d/mthesaur.txt"))
    ;;       nil (url-copy-file "https://archive.org/download/mobythesauruslis03202gut/mthesaur.txt" (substitute-in-file-name "$HOME/.emacs.d/mthesaur.txt")))
    ;;   (setq synonyms-file (substitute-in-file-name "$HOME/.emacs.d/mthesaur.txt"))
    ;;   (setq synonyms-cache-file (substitute-in-file-name "$HOME/.emacs.d/syn.cache"))
    ;;   (setq synonyms-match-more-flag nil)
    ;;   )
   #+END_SRC
** Iflipb
   #+BEGIN_SRC emacs-lisp
       ;; (exwm-input-set-key (kbd "M-<tab>") #'iflipb-next-buffer)
    ;; (exwm-input-set-key (kbd "s-<tab>") #'iflipb-next-buffer)
    ;; (exwm-input-set-key (kbd "s-<iso-lefttab>") #'iflipb-next-buffer)
   #+END_SRC
** Autoupdate
   #+BEGIN_SRC emacs-lisp
    ;; (use-package auto-package-update
    ;;   :init
    ;;   ;; Update every week
    ;;   (setq auto-package-update-interval 7)
    ;;   ;; Delete old versions
    ;;   (setq auto-package-update-delete-old-versions t)
    ;;   ;; Send a message saying that there will be an update
    ;;   (add-hook 'auto-package-update-before-hook
    ;;           (lambda () (message "I will update packages now")))
    ;;   ;; Update at startup
    ;;   ;;(auto-package-update-maybe)
    ;; )
   #+END_SRC
** Keyfreq
   #+BEGIN_SRC emacs-lisp
    ;; (use-package keyfreq
    ;;   :init
    ;;   (setq keyfreq-file "~/.emacs.p/keyfreq/statistics"
    ;;         keyfreq-file-lock "~/.emacs.p/keyfreq/lockfile")
    ;;   :config
    ;;   (keyfreq-mode 1)
    ;;   (keyfreq-autosave-mode 1))
   #+END_SRC
** Purcell's
   #+BEGIN_SRC emacs-lisp
    ;; (defun sanityinc/time-subtract-millis (b a)
    ;;   (* 1000.0 (float-time (time-subtract b a))))


    ;; (defvar sanityinc/require-times nil
    ;;   "A list of (FEATURE . LOAD-DURATION).
    ;; LOAD-DURATION is the time taken in milliseconds to load FEATURE.")

    ;; (defadvice require (around sanityinc/build-require-times (feature &optional filename noerror) activate)
    ;;   "Note in `sanityinc/require-times' the time taken to require each feature."
    ;;   (let* ((already-loaded (memq feature features))
    ;;          (require-start-time (and (not already-loaded) (current-time))))
    ;;     (prog1
    ;;         ad-do-it
    ;;       (when (and (not already-loaded) (memq feature features))
    ;;         (let ((time (sanityinc/time-subtract-millis (current-time) require-start-time)))
    ;;           (add-to-list 'sanityinc/require-times
    ;;                        (cons feature time)
    ;;                        t))))))

   #+END_SRC
** Smex
   To save minibuffer history
   #+BEGIN_SRC emacs-lisp
     (use-package smex
         :config (setq-default smex-save-file (expand-file-name ".smex-intems" user-emacs-directory))
         )
   #+END_SRC
** Spaceline
   #+BEGIN_SRC emacs-lisp

    ;; (use-package all-the-icons
    ;; (use-package fancy-battery
    ;; :config
    ;; (fancy-battery-mode)
    ;; )
    ;; (use-package spaceline
    ;; :config
    ;; )
    ;; (use-package yahoo-weather
    ;; (yahoo-weather-mode)
    ;; )
    ;; (use-package spaceline-all-the-icons
    ;; :after spaceline
    ;; :config (spaceline-all-the-icons-theme)
    ;; (spaceline-toggle-all-the-icons-battery-status-on)
    ;; (spaceline-toggle-all-the-icons-projectile-off)
    ;; (spaceline-toggle-all-the-icons-sunrise-on)
    ;; (spaceline-toggle-all-the-icons-sunset-on)
    ;; )

   #+END_SRC
** Languagetool
   #+BEGIN_SRC emacs-lisp
     ;; (use-package langtool
     ;;   :bind
     ;;   (("C-c 4 l" . langtool-check)
     ;;    ("C-c 4 d" . langtool-check-done))
     ;;   :config
     ;;   (setq langtool-default-language "en-US")
     ;;   (setq langtool-bin "/usr/bin/languagetool")
     ;;   (setq langtool-mother-tongue "en")
     ;;   ;; Errors as tooltip
     ;;   (defun langtool-autoshow-detail-popup (overlays)
     ;;     (when (require 'popup nil t)
     ;;       ;; Do not interrupt current popup
     ;;       (unless (or popup-instances
     ;;                   ;; suppress popup after type `C-g` .
     ;;                   (memq last-command '(keyboard-quit)))
     ;;         (let ((msg (langtool-details-error-message overlays)))
     ;;           (popup-tip msg)))))
     ;;   (setq langtool-autoshow-message-function
     ;;         'langtool-autoshow-detail-popup)
     ;;   )
   #+END_SRC
